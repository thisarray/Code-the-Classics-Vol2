<!DOCTYPE html>

<html lang="en-US">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>leadingedge</title>
  <script src="../../jsgame0.js"></script>
  <style type="text/css" media="screen">
body {
  background-color: white;
  color: black;
}
.hidden {
  display: none;
}
#original {
  margin-left: 1em;
}
  </style>
</head>

<body>
<section id="imageLoader" class="hidden">
  <img class="hidden" src="images/arrow_forward.png" alt="arrow_forward" data-name="arrow_forward">
  <img class="hidden" src="images/arrow_left.png" alt="arrow_left" data-name="arrow_left">
  <img class="hidden" src="images/arrow_right.png" alt="arrow_right" data-name="arrow_right">
  <img class="hidden" src="images/background.png" alt="background" data-name="background">
  <img class="hidden" src="images/billboard00.png" alt="billboard00" data-name="billboard00">
  <img class="hidden" src="images/billboard01.png" alt="billboard01" data-name="billboard01">
  <img class="hidden" src="images/billboard02.png" alt="billboard02" data-name="billboard02">
  <img class="hidden" src="images/billboard03.png" alt="billboard03" data-name="billboard03">
  <img class="hidden" src="images/car_a_0_0.png" alt="car_a_0_0" data-name="car_a_0_0">
  <img class="hidden" src="images/car_a_0_1.png" alt="car_a_0_1" data-name="car_a_0_1">
  <img class="hidden" src="images/car_a_0_2.png" alt="car_a_0_2" data-name="car_a_0_2">
  <img class="hidden" src="images/car_a_0_3.png" alt="car_a_0_3" data-name="car_a_0_3">
  <img class="hidden" src="images/car_a_0_4.png" alt="car_a_0_4" data-name="car_a_0_4">
  <img class="hidden" src="images/car_a_0_5.png" alt="car_a_0_5" data-name="car_a_0_5">
  <img class="hidden" src="images/car_a_1_0.png" alt="car_a_1_0" data-name="car_a_1_0">
  <img class="hidden" src="images/car_a_1_1.png" alt="car_a_1_1" data-name="car_a_1_1">
  <img class="hidden" src="images/car_a_1_2.png" alt="car_a_1_2" data-name="car_a_1_2">
  <img class="hidden" src="images/car_a_1_3.png" alt="car_a_1_3" data-name="car_a_1_3">
  <img class="hidden" src="images/car_a_1_4.png" alt="car_a_1_4" data-name="car_a_1_4">
  <img class="hidden" src="images/car_a_1_5.png" alt="car_a_1_5" data-name="car_a_1_5">
  <img class="hidden" src="images/car_a_2_0.png" alt="car_a_2_0" data-name="car_a_2_0">
  <img class="hidden" src="images/car_a_2_1.png" alt="car_a_2_1" data-name="car_a_2_1">
  <img class="hidden" src="images/car_a_2_2.png" alt="car_a_2_2" data-name="car_a_2_2">
  <img class="hidden" src="images/car_a_2_3.png" alt="car_a_2_3" data-name="car_a_2_3">
  <img class="hidden" src="images/car_a_2_4.png" alt="car_a_2_4" data-name="car_a_2_4">
  <img class="hidden" src="images/car_a_2_5.png" alt="car_a_2_5" data-name="car_a_2_5">
  <img class="hidden" src="images/car_a_3_0.png" alt="car_a_3_0" data-name="car_a_3_0">
  <img class="hidden" src="images/car_a_3_1.png" alt="car_a_3_1" data-name="car_a_3_1">
  <img class="hidden" src="images/car_a_3_2.png" alt="car_a_3_2" data-name="car_a_3_2">
  <img class="hidden" src="images/car_a_3_3.png" alt="car_a_3_3" data-name="car_a_3_3">
  <img class="hidden" src="images/car_a_3_4.png" alt="car_a_3_4" data-name="car_a_3_4">
  <img class="hidden" src="images/car_a_3_5.png" alt="car_a_3_5" data-name="car_a_3_5">
  <img class="hidden" src="images/car_a_4_0.png" alt="car_a_4_0" data-name="car_a_4_0">
  <img class="hidden" src="images/car_a_4_1.png" alt="car_a_4_1" data-name="car_a_4_1">
  <img class="hidden" src="images/car_a_4_2.png" alt="car_a_4_2" data-name="car_a_4_2">
  <img class="hidden" src="images/car_a_4_3.png" alt="car_a_4_3" data-name="car_a_4_3">
  <img class="hidden" src="images/car_a_4_4.png" alt="car_a_4_4" data-name="car_a_4_4">
  <img class="hidden" src="images/car_a_4_5.png" alt="car_a_4_5" data-name="car_a_4_5">
  <img class="hidden" src="images/car_a_n1_0.png" alt="car_a_n1_0" data-name="car_a_n1_0">
  <img class="hidden" src="images/car_a_n1_1.png" alt="car_a_n1_1" data-name="car_a_n1_1">
  <img class="hidden" src="images/car_a_n1_2.png" alt="car_a_n1_2" data-name="car_a_n1_2">
  <img class="hidden" src="images/car_a_n1_3.png" alt="car_a_n1_3" data-name="car_a_n1_3">
  <img class="hidden" src="images/car_a_n1_4.png" alt="car_a_n1_4" data-name="car_a_n1_4">
  <img class="hidden" src="images/car_a_n1_5.png" alt="car_a_n1_5" data-name="car_a_n1_5">
  <img class="hidden" src="images/car_a_n2_0.png" alt="car_a_n2_0" data-name="car_a_n2_0">
  <img class="hidden" src="images/car_a_n2_1.png" alt="car_a_n2_1" data-name="car_a_n2_1">
  <img class="hidden" src="images/car_a_n2_2.png" alt="car_a_n2_2" data-name="car_a_n2_2">
  <img class="hidden" src="images/car_a_n2_3.png" alt="car_a_n2_3" data-name="car_a_n2_3">
  <img class="hidden" src="images/car_a_n2_4.png" alt="car_a_n2_4" data-name="car_a_n2_4">
  <img class="hidden" src="images/car_a_n2_5.png" alt="car_a_n2_5" data-name="car_a_n2_5">
  <img class="hidden" src="images/car_a_n3_0.png" alt="car_a_n3_0" data-name="car_a_n3_0">
  <img class="hidden" src="images/car_a_n3_1.png" alt="car_a_n3_1" data-name="car_a_n3_1">
  <img class="hidden" src="images/car_a_n3_2.png" alt="car_a_n3_2" data-name="car_a_n3_2">
  <img class="hidden" src="images/car_a_n3_3.png" alt="car_a_n3_3" data-name="car_a_n3_3">
  <img class="hidden" src="images/car_a_n3_4.png" alt="car_a_n3_4" data-name="car_a_n3_4">
  <img class="hidden" src="images/car_a_n3_5.png" alt="car_a_n3_5" data-name="car_a_n3_5">
  <img class="hidden" src="images/car_a_n4_0.png" alt="car_a_n4_0" data-name="car_a_n4_0">
  <img class="hidden" src="images/car_a_n4_1.png" alt="car_a_n4_1" data-name="car_a_n4_1">
  <img class="hidden" src="images/car_a_n4_2.png" alt="car_a_n4_2" data-name="car_a_n4_2">
  <img class="hidden" src="images/car_a_n4_3.png" alt="car_a_n4_3" data-name="car_a_n4_3">
  <img class="hidden" src="images/car_a_n4_4.png" alt="car_a_n4_4" data-name="car_a_n4_4">
  <img class="hidden" src="images/car_a_n4_5.png" alt="car_a_n4_5" data-name="car_a_n4_5">
  <img class="hidden" src="images/car_b_0_0.png" alt="car_b_0_0" data-name="car_b_0_0">
  <img class="hidden" src="images/car_b_0_1.png" alt="car_b_0_1" data-name="car_b_0_1">
  <img class="hidden" src="images/car_b_0_2.png" alt="car_b_0_2" data-name="car_b_0_2">
  <img class="hidden" src="images/car_b_0_3.png" alt="car_b_0_3" data-name="car_b_0_3">
  <img class="hidden" src="images/car_b_0_4.png" alt="car_b_0_4" data-name="car_b_0_4">
  <img class="hidden" src="images/car_b_0_5.png" alt="car_b_0_5" data-name="car_b_0_5">
  <img class="hidden" src="images/car_b_1_0.png" alt="car_b_1_0" data-name="car_b_1_0">
  <img class="hidden" src="images/car_b_1_1.png" alt="car_b_1_1" data-name="car_b_1_1">
  <img class="hidden" src="images/car_b_1_2.png" alt="car_b_1_2" data-name="car_b_1_2">
  <img class="hidden" src="images/car_b_1_3.png" alt="car_b_1_3" data-name="car_b_1_3">
  <img class="hidden" src="images/car_b_1_4.png" alt="car_b_1_4" data-name="car_b_1_4">
  <img class="hidden" src="images/car_b_1_5.png" alt="car_b_1_5" data-name="car_b_1_5">
  <img class="hidden" src="images/car_b_2_0.png" alt="car_b_2_0" data-name="car_b_2_0">
  <img class="hidden" src="images/car_b_2_1.png" alt="car_b_2_1" data-name="car_b_2_1">
  <img class="hidden" src="images/car_b_2_2.png" alt="car_b_2_2" data-name="car_b_2_2">
  <img class="hidden" src="images/car_b_2_3.png" alt="car_b_2_3" data-name="car_b_2_3">
  <img class="hidden" src="images/car_b_2_4.png" alt="car_b_2_4" data-name="car_b_2_4">
  <img class="hidden" src="images/car_b_2_5.png" alt="car_b_2_5" data-name="car_b_2_5">
  <img class="hidden" src="images/car_b_3_0.png" alt="car_b_3_0" data-name="car_b_3_0">
  <img class="hidden" src="images/car_b_3_1.png" alt="car_b_3_1" data-name="car_b_3_1">
  <img class="hidden" src="images/car_b_3_2.png" alt="car_b_3_2" data-name="car_b_3_2">
  <img class="hidden" src="images/car_b_3_3.png" alt="car_b_3_3" data-name="car_b_3_3">
  <img class="hidden" src="images/car_b_3_4.png" alt="car_b_3_4" data-name="car_b_3_4">
  <img class="hidden" src="images/car_b_3_5.png" alt="car_b_3_5" data-name="car_b_3_5">
  <img class="hidden" src="images/car_b_4_0.png" alt="car_b_4_0" data-name="car_b_4_0">
  <img class="hidden" src="images/car_b_4_1.png" alt="car_b_4_1" data-name="car_b_4_1">
  <img class="hidden" src="images/car_b_4_2.png" alt="car_b_4_2" data-name="car_b_4_2">
  <img class="hidden" src="images/car_b_4_3.png" alt="car_b_4_3" data-name="car_b_4_3">
  <img class="hidden" src="images/car_b_4_4.png" alt="car_b_4_4" data-name="car_b_4_4">
  <img class="hidden" src="images/car_b_4_5.png" alt="car_b_4_5" data-name="car_b_4_5">
  <img class="hidden" src="images/car_b_n1_0.png" alt="car_b_n1_0" data-name="car_b_n1_0">
  <img class="hidden" src="images/car_b_n1_1.png" alt="car_b_n1_1" data-name="car_b_n1_1">
  <img class="hidden" src="images/car_b_n1_2.png" alt="car_b_n1_2" data-name="car_b_n1_2">
  <img class="hidden" src="images/car_b_n1_3.png" alt="car_b_n1_3" data-name="car_b_n1_3">
  <img class="hidden" src="images/car_b_n1_4.png" alt="car_b_n1_4" data-name="car_b_n1_4">
  <img class="hidden" src="images/car_b_n1_5.png" alt="car_b_n1_5" data-name="car_b_n1_5">
  <img class="hidden" src="images/car_b_n2_0.png" alt="car_b_n2_0" data-name="car_b_n2_0">
  <img class="hidden" src="images/car_b_n2_1.png" alt="car_b_n2_1" data-name="car_b_n2_1">
  <img class="hidden" src="images/car_b_n2_2.png" alt="car_b_n2_2" data-name="car_b_n2_2">
  <img class="hidden" src="images/car_b_n2_3.png" alt="car_b_n2_3" data-name="car_b_n2_3">
  <img class="hidden" src="images/car_b_n2_4.png" alt="car_b_n2_4" data-name="car_b_n2_4">
  <img class="hidden" src="images/car_b_n2_5.png" alt="car_b_n2_5" data-name="car_b_n2_5">
  <img class="hidden" src="images/car_b_n3_0.png" alt="car_b_n3_0" data-name="car_b_n3_0">
  <img class="hidden" src="images/car_b_n3_1.png" alt="car_b_n3_1" data-name="car_b_n3_1">
  <img class="hidden" src="images/car_b_n3_2.png" alt="car_b_n3_2" data-name="car_b_n3_2">
  <img class="hidden" src="images/car_b_n3_3.png" alt="car_b_n3_3" data-name="car_b_n3_3">
  <img class="hidden" src="images/car_b_n3_4.png" alt="car_b_n3_4" data-name="car_b_n3_4">
  <img class="hidden" src="images/car_b_n3_5.png" alt="car_b_n3_5" data-name="car_b_n3_5">
  <img class="hidden" src="images/car_b_n4_0.png" alt="car_b_n4_0" data-name="car_b_n4_0">
  <img class="hidden" src="images/car_b_n4_1.png" alt="car_b_n4_1" data-name="car_b_n4_1">
  <img class="hidden" src="images/car_b_n4_2.png" alt="car_b_n4_2" data-name="car_b_n4_2">
  <img class="hidden" src="images/car_b_n4_3.png" alt="car_b_n4_3" data-name="car_b_n4_3">
  <img class="hidden" src="images/car_b_n4_4.png" alt="car_b_n4_4" data-name="car_b_n4_4">
  <img class="hidden" src="images/car_b_n4_5.png" alt="car_b_n4_5" data-name="car_b_n4_5">
  <img class="hidden" src="images/car_c_0_0.png" alt="car_c_0_0" data-name="car_c_0_0">
  <img class="hidden" src="images/car_c_0_1.png" alt="car_c_0_1" data-name="car_c_0_1">
  <img class="hidden" src="images/car_c_0_2.png" alt="car_c_0_2" data-name="car_c_0_2">
  <img class="hidden" src="images/car_c_0_3.png" alt="car_c_0_3" data-name="car_c_0_3">
  <img class="hidden" src="images/car_c_0_4.png" alt="car_c_0_4" data-name="car_c_0_4">
  <img class="hidden" src="images/car_c_0_5.png" alt="car_c_0_5" data-name="car_c_0_5">
  <img class="hidden" src="images/car_c_1_0.png" alt="car_c_1_0" data-name="car_c_1_0">
  <img class="hidden" src="images/car_c_1_1.png" alt="car_c_1_1" data-name="car_c_1_1">
  <img class="hidden" src="images/car_c_1_2.png" alt="car_c_1_2" data-name="car_c_1_2">
  <img class="hidden" src="images/car_c_1_3.png" alt="car_c_1_3" data-name="car_c_1_3">
  <img class="hidden" src="images/car_c_1_4.png" alt="car_c_1_4" data-name="car_c_1_4">
  <img class="hidden" src="images/car_c_1_5.png" alt="car_c_1_5" data-name="car_c_1_5">
  <img class="hidden" src="images/car_c_2_0.png" alt="car_c_2_0" data-name="car_c_2_0">
  <img class="hidden" src="images/car_c_2_1.png" alt="car_c_2_1" data-name="car_c_2_1">
  <img class="hidden" src="images/car_c_2_2.png" alt="car_c_2_2" data-name="car_c_2_2">
  <img class="hidden" src="images/car_c_2_3.png" alt="car_c_2_3" data-name="car_c_2_3">
  <img class="hidden" src="images/car_c_2_4.png" alt="car_c_2_4" data-name="car_c_2_4">
  <img class="hidden" src="images/car_c_2_5.png" alt="car_c_2_5" data-name="car_c_2_5">
  <img class="hidden" src="images/car_c_3_0.png" alt="car_c_3_0" data-name="car_c_3_0">
  <img class="hidden" src="images/car_c_3_1.png" alt="car_c_3_1" data-name="car_c_3_1">
  <img class="hidden" src="images/car_c_3_2.png" alt="car_c_3_2" data-name="car_c_3_2">
  <img class="hidden" src="images/car_c_3_3.png" alt="car_c_3_3" data-name="car_c_3_3">
  <img class="hidden" src="images/car_c_3_4.png" alt="car_c_3_4" data-name="car_c_3_4">
  <img class="hidden" src="images/car_c_3_5.png" alt="car_c_3_5" data-name="car_c_3_5">
  <img class="hidden" src="images/car_c_4_0.png" alt="car_c_4_0" data-name="car_c_4_0">
  <img class="hidden" src="images/car_c_4_1.png" alt="car_c_4_1" data-name="car_c_4_1">
  <img class="hidden" src="images/car_c_4_2.png" alt="car_c_4_2" data-name="car_c_4_2">
  <img class="hidden" src="images/car_c_4_3.png" alt="car_c_4_3" data-name="car_c_4_3">
  <img class="hidden" src="images/car_c_4_4.png" alt="car_c_4_4" data-name="car_c_4_4">
  <img class="hidden" src="images/car_c_4_5.png" alt="car_c_4_5" data-name="car_c_4_5">
  <img class="hidden" src="images/car_c_n1_0.png" alt="car_c_n1_0" data-name="car_c_n1_0">
  <img class="hidden" src="images/car_c_n1_1.png" alt="car_c_n1_1" data-name="car_c_n1_1">
  <img class="hidden" src="images/car_c_n1_2.png" alt="car_c_n1_2" data-name="car_c_n1_2">
  <img class="hidden" src="images/car_c_n1_3.png" alt="car_c_n1_3" data-name="car_c_n1_3">
  <img class="hidden" src="images/car_c_n1_4.png" alt="car_c_n1_4" data-name="car_c_n1_4">
  <img class="hidden" src="images/car_c_n1_5.png" alt="car_c_n1_5" data-name="car_c_n1_5">
  <img class="hidden" src="images/car_c_n2_0.png" alt="car_c_n2_0" data-name="car_c_n2_0">
  <img class="hidden" src="images/car_c_n2_1.png" alt="car_c_n2_1" data-name="car_c_n2_1">
  <img class="hidden" src="images/car_c_n2_2.png" alt="car_c_n2_2" data-name="car_c_n2_2">
  <img class="hidden" src="images/car_c_n2_3.png" alt="car_c_n2_3" data-name="car_c_n2_3">
  <img class="hidden" src="images/car_c_n2_4.png" alt="car_c_n2_4" data-name="car_c_n2_4">
  <img class="hidden" src="images/car_c_n2_5.png" alt="car_c_n2_5" data-name="car_c_n2_5">
  <img class="hidden" src="images/car_c_n3_0.png" alt="car_c_n3_0" data-name="car_c_n3_0">
  <img class="hidden" src="images/car_c_n3_1.png" alt="car_c_n3_1" data-name="car_c_n3_1">
  <img class="hidden" src="images/car_c_n3_2.png" alt="car_c_n3_2" data-name="car_c_n3_2">
  <img class="hidden" src="images/car_c_n3_3.png" alt="car_c_n3_3" data-name="car_c_n3_3">
  <img class="hidden" src="images/car_c_n3_4.png" alt="car_c_n3_4" data-name="car_c_n3_4">
  <img class="hidden" src="images/car_c_n3_5.png" alt="car_c_n3_5" data-name="car_c_n3_5">
  <img class="hidden" src="images/car_c_n4_0.png" alt="car_c_n4_0" data-name="car_c_n4_0">
  <img class="hidden" src="images/car_c_n4_1.png" alt="car_c_n4_1" data-name="car_c_n4_1">
  <img class="hidden" src="images/car_c_n4_2.png" alt="car_c_n4_2" data-name="car_c_n4_2">
  <img class="hidden" src="images/car_c_n4_3.png" alt="car_c_n4_3" data-name="car_c_n4_3">
  <img class="hidden" src="images/car_c_n4_4.png" alt="car_c_n4_4" data-name="car_c_n4_4">
  <img class="hidden" src="images/car_c_n4_5.png" alt="car_c_n4_5" data-name="car_c_n4_5">
  <img class="hidden" src="images/car_d_0_0.png" alt="car_d_0_0" data-name="car_d_0_0">
  <img class="hidden" src="images/car_d_0_1.png" alt="car_d_0_1" data-name="car_d_0_1">
  <img class="hidden" src="images/car_d_0_2.png" alt="car_d_0_2" data-name="car_d_0_2">
  <img class="hidden" src="images/car_d_0_3.png" alt="car_d_0_3" data-name="car_d_0_3">
  <img class="hidden" src="images/car_d_0_4.png" alt="car_d_0_4" data-name="car_d_0_4">
  <img class="hidden" src="images/car_d_0_5.png" alt="car_d_0_5" data-name="car_d_0_5">
  <img class="hidden" src="images/car_d_1_0.png" alt="car_d_1_0" data-name="car_d_1_0">
  <img class="hidden" src="images/car_d_1_1.png" alt="car_d_1_1" data-name="car_d_1_1">
  <img class="hidden" src="images/car_d_1_2.png" alt="car_d_1_2" data-name="car_d_1_2">
  <img class="hidden" src="images/car_d_1_3.png" alt="car_d_1_3" data-name="car_d_1_3">
  <img class="hidden" src="images/car_d_1_4.png" alt="car_d_1_4" data-name="car_d_1_4">
  <img class="hidden" src="images/car_d_1_5.png" alt="car_d_1_5" data-name="car_d_1_5">
  <img class="hidden" src="images/car_d_2_0.png" alt="car_d_2_0" data-name="car_d_2_0">
  <img class="hidden" src="images/car_d_2_1.png" alt="car_d_2_1" data-name="car_d_2_1">
  <img class="hidden" src="images/car_d_2_2.png" alt="car_d_2_2" data-name="car_d_2_2">
  <img class="hidden" src="images/car_d_2_3.png" alt="car_d_2_3" data-name="car_d_2_3">
  <img class="hidden" src="images/car_d_2_4.png" alt="car_d_2_4" data-name="car_d_2_4">
  <img class="hidden" src="images/car_d_2_5.png" alt="car_d_2_5" data-name="car_d_2_5">
  <img class="hidden" src="images/car_d_3_0.png" alt="car_d_3_0" data-name="car_d_3_0">
  <img class="hidden" src="images/car_d_3_1.png" alt="car_d_3_1" data-name="car_d_3_1">
  <img class="hidden" src="images/car_d_3_2.png" alt="car_d_3_2" data-name="car_d_3_2">
  <img class="hidden" src="images/car_d_3_3.png" alt="car_d_3_3" data-name="car_d_3_3">
  <img class="hidden" src="images/car_d_3_4.png" alt="car_d_3_4" data-name="car_d_3_4">
  <img class="hidden" src="images/car_d_3_5.png" alt="car_d_3_5" data-name="car_d_3_5">
  <img class="hidden" src="images/car_d_4_0.png" alt="car_d_4_0" data-name="car_d_4_0">
  <img class="hidden" src="images/car_d_4_1.png" alt="car_d_4_1" data-name="car_d_4_1">
  <img class="hidden" src="images/car_d_4_2.png" alt="car_d_4_2" data-name="car_d_4_2">
  <img class="hidden" src="images/car_d_4_3.png" alt="car_d_4_3" data-name="car_d_4_3">
  <img class="hidden" src="images/car_d_4_4.png" alt="car_d_4_4" data-name="car_d_4_4">
  <img class="hidden" src="images/car_d_4_5.png" alt="car_d_4_5" data-name="car_d_4_5">
  <img class="hidden" src="images/car_d_n1_0.png" alt="car_d_n1_0" data-name="car_d_n1_0">
  <img class="hidden" src="images/car_d_n1_1.png" alt="car_d_n1_1" data-name="car_d_n1_1">
  <img class="hidden" src="images/car_d_n1_2.png" alt="car_d_n1_2" data-name="car_d_n1_2">
  <img class="hidden" src="images/car_d_n1_3.png" alt="car_d_n1_3" data-name="car_d_n1_3">
  <img class="hidden" src="images/car_d_n1_4.png" alt="car_d_n1_4" data-name="car_d_n1_4">
  <img class="hidden" src="images/car_d_n1_5.png" alt="car_d_n1_5" data-name="car_d_n1_5">
  <img class="hidden" src="images/car_d_n2_0.png" alt="car_d_n2_0" data-name="car_d_n2_0">
  <img class="hidden" src="images/car_d_n2_1.png" alt="car_d_n2_1" data-name="car_d_n2_1">
  <img class="hidden" src="images/car_d_n2_2.png" alt="car_d_n2_2" data-name="car_d_n2_2">
  <img class="hidden" src="images/car_d_n2_3.png" alt="car_d_n2_3" data-name="car_d_n2_3">
  <img class="hidden" src="images/car_d_n2_4.png" alt="car_d_n2_4" data-name="car_d_n2_4">
  <img class="hidden" src="images/car_d_n2_5.png" alt="car_d_n2_5" data-name="car_d_n2_5">
  <img class="hidden" src="images/car_d_n3_0.png" alt="car_d_n3_0" data-name="car_d_n3_0">
  <img class="hidden" src="images/car_d_n3_1.png" alt="car_d_n3_1" data-name="car_d_n3_1">
  <img class="hidden" src="images/car_d_n3_2.png" alt="car_d_n3_2" data-name="car_d_n3_2">
  <img class="hidden" src="images/car_d_n3_3.png" alt="car_d_n3_3" data-name="car_d_n3_3">
  <img class="hidden" src="images/car_d_n3_4.png" alt="car_d_n3_4" data-name="car_d_n3_4">
  <img class="hidden" src="images/car_d_n3_5.png" alt="car_d_n3_5" data-name="car_d_n3_5">
  <img class="hidden" src="images/car_d_n4_0.png" alt="car_d_n4_0" data-name="car_d_n4_0">
  <img class="hidden" src="images/car_d_n4_1.png" alt="car_d_n4_1" data-name="car_d_n4_1">
  <img class="hidden" src="images/car_d_n4_2.png" alt="car_d_n4_2" data-name="car_d_n4_2">
  <img class="hidden" src="images/car_d_n4_3.png" alt="car_d_n4_3" data-name="car_d_n4_3">
  <img class="hidden" src="images/car_d_n4_4.png" alt="car_d_n4_4" data-name="car_d_n4_4">
  <img class="hidden" src="images/car_d_n4_5.png" alt="car_d_n4_5" data-name="car_d_n4_5">
  <img class="hidden" src="images/car_e_0_0.png" alt="car_e_0_0" data-name="car_e_0_0">
  <img class="hidden" src="images/car_e_0_1.png" alt="car_e_0_1" data-name="car_e_0_1">
  <img class="hidden" src="images/car_e_0_2.png" alt="car_e_0_2" data-name="car_e_0_2">
  <img class="hidden" src="images/car_e_0_3.png" alt="car_e_0_3" data-name="car_e_0_3">
  <img class="hidden" src="images/car_e_0_4.png" alt="car_e_0_4" data-name="car_e_0_4">
  <img class="hidden" src="images/car_e_0_5.png" alt="car_e_0_5" data-name="car_e_0_5">
  <img class="hidden" src="images/car_e_1_0.png" alt="car_e_1_0" data-name="car_e_1_0">
  <img class="hidden" src="images/car_e_1_1.png" alt="car_e_1_1" data-name="car_e_1_1">
  <img class="hidden" src="images/car_e_1_2.png" alt="car_e_1_2" data-name="car_e_1_2">
  <img class="hidden" src="images/car_e_1_3.png" alt="car_e_1_3" data-name="car_e_1_3">
  <img class="hidden" src="images/car_e_1_4.png" alt="car_e_1_4" data-name="car_e_1_4">
  <img class="hidden" src="images/car_e_1_5.png" alt="car_e_1_5" data-name="car_e_1_5">
  <img class="hidden" src="images/car_e_2_0.png" alt="car_e_2_0" data-name="car_e_2_0">
  <img class="hidden" src="images/car_e_2_1.png" alt="car_e_2_1" data-name="car_e_2_1">
  <img class="hidden" src="images/car_e_2_2.png" alt="car_e_2_2" data-name="car_e_2_2">
  <img class="hidden" src="images/car_e_2_3.png" alt="car_e_2_3" data-name="car_e_2_3">
  <img class="hidden" src="images/car_e_2_4.png" alt="car_e_2_4" data-name="car_e_2_4">
  <img class="hidden" src="images/car_e_2_5.png" alt="car_e_2_5" data-name="car_e_2_5">
  <img class="hidden" src="images/car_e_3_0.png" alt="car_e_3_0" data-name="car_e_3_0">
  <img class="hidden" src="images/car_e_3_1.png" alt="car_e_3_1" data-name="car_e_3_1">
  <img class="hidden" src="images/car_e_3_2.png" alt="car_e_3_2" data-name="car_e_3_2">
  <img class="hidden" src="images/car_e_3_3.png" alt="car_e_3_3" data-name="car_e_3_3">
  <img class="hidden" src="images/car_e_3_4.png" alt="car_e_3_4" data-name="car_e_3_4">
  <img class="hidden" src="images/car_e_3_5.png" alt="car_e_3_5" data-name="car_e_3_5">
  <img class="hidden" src="images/car_e_4_0.png" alt="car_e_4_0" data-name="car_e_4_0">
  <img class="hidden" src="images/car_e_4_1.png" alt="car_e_4_1" data-name="car_e_4_1">
  <img class="hidden" src="images/car_e_4_2.png" alt="car_e_4_2" data-name="car_e_4_2">
  <img class="hidden" src="images/car_e_4_3.png" alt="car_e_4_3" data-name="car_e_4_3">
  <img class="hidden" src="images/car_e_4_4.png" alt="car_e_4_4" data-name="car_e_4_4">
  <img class="hidden" src="images/car_e_4_5.png" alt="car_e_4_5" data-name="car_e_4_5">
  <img class="hidden" src="images/car_e_n1_0.png" alt="car_e_n1_0" data-name="car_e_n1_0">
  <img class="hidden" src="images/car_e_n1_1.png" alt="car_e_n1_1" data-name="car_e_n1_1">
  <img class="hidden" src="images/car_e_n1_2.png" alt="car_e_n1_2" data-name="car_e_n1_2">
  <img class="hidden" src="images/car_e_n1_3.png" alt="car_e_n1_3" data-name="car_e_n1_3">
  <img class="hidden" src="images/car_e_n1_4.png" alt="car_e_n1_4" data-name="car_e_n1_4">
  <img class="hidden" src="images/car_e_n1_5.png" alt="car_e_n1_5" data-name="car_e_n1_5">
  <img class="hidden" src="images/car_e_n2_0.png" alt="car_e_n2_0" data-name="car_e_n2_0">
  <img class="hidden" src="images/car_e_n2_1.png" alt="car_e_n2_1" data-name="car_e_n2_1">
  <img class="hidden" src="images/car_e_n2_2.png" alt="car_e_n2_2" data-name="car_e_n2_2">
  <img class="hidden" src="images/car_e_n2_3.png" alt="car_e_n2_3" data-name="car_e_n2_3">
  <img class="hidden" src="images/car_e_n2_4.png" alt="car_e_n2_4" data-name="car_e_n2_4">
  <img class="hidden" src="images/car_e_n2_5.png" alt="car_e_n2_5" data-name="car_e_n2_5">
  <img class="hidden" src="images/car_e_n3_0.png" alt="car_e_n3_0" data-name="car_e_n3_0">
  <img class="hidden" src="images/car_e_n3_1.png" alt="car_e_n3_1" data-name="car_e_n3_1">
  <img class="hidden" src="images/car_e_n3_2.png" alt="car_e_n3_2" data-name="car_e_n3_2">
  <img class="hidden" src="images/car_e_n3_3.png" alt="car_e_n3_3" data-name="car_e_n3_3">
  <img class="hidden" src="images/car_e_n3_4.png" alt="car_e_n3_4" data-name="car_e_n3_4">
  <img class="hidden" src="images/car_e_n3_5.png" alt="car_e_n3_5" data-name="car_e_n3_5">
  <img class="hidden" src="images/car_e_n4_0.png" alt="car_e_n4_0" data-name="car_e_n4_0">
  <img class="hidden" src="images/car_e_n4_1.png" alt="car_e_n4_1" data-name="car_e_n4_1">
  <img class="hidden" src="images/car_e_n4_2.png" alt="car_e_n4_2" data-name="car_e_n4_2">
  <img class="hidden" src="images/car_e_n4_3.png" alt="car_e_n4_3" data-name="car_e_n4_3">
  <img class="hidden" src="images/car_e_n4_4.png" alt="car_e_n4_4" data-name="car_e_n4_4">
  <img class="hidden" src="images/car_e_n4_5.png" alt="car_e_n4_5" data-name="car_e_n4_5">
  <img class="hidden" src="images/explode00.png" alt="explode00" data-name="explode00">
  <img class="hidden" src="images/explode01.png" alt="explode01" data-name="explode01">
  <img class="hidden" src="images/explode02.png" alt="explode02" data-name="explode02">
  <img class="hidden" src="images/explode03.png" alt="explode03" data-name="explode03">
  <img class="hidden" src="images/explode04.png" alt="explode04" data-name="explode04">
  <img class="hidden" src="images/explode05.png" alt="explode05" data-name="explode05">
  <img class="hidden" src="images/explode06.png" alt="explode06" data-name="explode06">
  <img class="hidden" src="images/explode07.png" alt="explode07" data-name="explode07">
  <img class="hidden" src="images/explode08.png" alt="explode08" data-name="explode08">
  <img class="hidden" src="images/explode09.png" alt="explode09" data-name="explode09">
  <img class="hidden" src="images/explode10.png" alt="explode10" data-name="explode10">
  <img class="hidden" src="images/explode11.png" alt="explode11" data-name="explode11">
  <img class="hidden" src="images/explode12.png" alt="explode12" data-name="explode12">
  <img class="hidden" src="images/explode13.png" alt="explode13" data-name="explode13">
  <img class="hidden" src="images/explode14.png" alt="explode14" data-name="explode14">
  <img class="hidden" src="images/explode15.png" alt="explode15" data-name="explode15">
  <img class="hidden" src="images/font033.png" alt="font033" data-name="font033">
  <img class="hidden" src="images/font046.png" alt="font046" data-name="font046">
  <img class="hidden" src="images/font048.png" alt="font048" data-name="font048">
  <img class="hidden" src="images/font049.png" alt="font049" data-name="font049">
  <img class="hidden" src="images/font050.png" alt="font050" data-name="font050">
  <img class="hidden" src="images/font051.png" alt="font051" data-name="font051">
  <img class="hidden" src="images/font052.png" alt="font052" data-name="font052">
  <img class="hidden" src="images/font053.png" alt="font053" data-name="font053">
  <img class="hidden" src="images/font054.png" alt="font054" data-name="font054">
  <img class="hidden" src="images/font055.png" alt="font055" data-name="font055">
  <img class="hidden" src="images/font056.png" alt="font056" data-name="font056">
  <img class="hidden" src="images/font057.png" alt="font057" data-name="font057">
  <img class="hidden" src="images/font058.png" alt="font058" data-name="font058">
  <img class="hidden" src="images/font065.png" alt="font065" data-name="font065">
  <img class="hidden" src="images/font066.png" alt="font066" data-name="font066">
  <img class="hidden" src="images/font067.png" alt="font067" data-name="font067">
  <img class="hidden" src="images/font068.png" alt="font068" data-name="font068">
  <img class="hidden" src="images/font069.png" alt="font069" data-name="font069">
  <img class="hidden" src="images/font070.png" alt="font070" data-name="font070">
  <img class="hidden" src="images/font071.png" alt="font071" data-name="font071">
  <img class="hidden" src="images/font072.png" alt="font072" data-name="font072">
  <img class="hidden" src="images/font073.png" alt="font073" data-name="font073">
  <img class="hidden" src="images/font074.png" alt="font074" data-name="font074">
  <img class="hidden" src="images/font075.png" alt="font075" data-name="font075">
  <img class="hidden" src="images/font076.png" alt="font076" data-name="font076">
  <img class="hidden" src="images/font077.png" alt="font077" data-name="font077">
  <img class="hidden" src="images/font078.png" alt="font078" data-name="font078">
  <img class="hidden" src="images/font079.png" alt="font079" data-name="font079">
  <img class="hidden" src="images/font080.png" alt="font080" data-name="font080">
  <img class="hidden" src="images/font081.png" alt="font081" data-name="font081">
  <img class="hidden" src="images/font082.png" alt="font082" data-name="font082">
  <img class="hidden" src="images/font083.png" alt="font083" data-name="font083">
  <img class="hidden" src="images/font084.png" alt="font084" data-name="font084">
  <img class="hidden" src="images/font085.png" alt="font085" data-name="font085">
  <img class="hidden" src="images/font086.png" alt="font086" data-name="font086">
  <img class="hidden" src="images/font087.png" alt="font087" data-name="font087">
  <img class="hidden" src="images/font088.png" alt="font088" data-name="font088">
  <img class="hidden" src="images/font089.png" alt="font089" data-name="font089">
  <img class="hidden" src="images/font090.png" alt="font090" data-name="font090">
  <img class="hidden" src="images/left_light.png" alt="left_light" data-name="left_light">
  <img class="hidden" src="images/logo.png" alt="logo" data-name="logo">
  <img class="hidden" src="images/right_light.png" alt="right_light" data-name="right_light">
  <img class="hidden" src="images/start0.png" alt="start0" data-name="start0">
  <img class="hidden" src="images/start1.png" alt="start1" data-name="start1">
  <img class="hidden" src="images/start2.png" alt="start2" data-name="start2">
  <img class="hidden" src="images/start3.png" alt="start3" data-name="start3">
  <img class="hidden" src="images/start4.png" alt="start4" data-name="start4">
  <img class="hidden" src="images/start5.png" alt="start5" data-name="start5">
  <img class="hidden" src="images/status.png" alt="status" data-name="status">
  <img class="hidden" src="images/status1b_048.png" alt="status1b_048" data-name="status1b_048">
  <img class="hidden" src="images/status1b_049.png" alt="status1b_049" data-name="status1b_049">
  <img class="hidden" src="images/status1b_050.png" alt="status1b_050" data-name="status1b_050">
  <img class="hidden" src="images/status1b_051.png" alt="status1b_051" data-name="status1b_051">
  <img class="hidden" src="images/status1b_052.png" alt="status1b_052" data-name="status1b_052">
  <img class="hidden" src="images/status1b_053.png" alt="status1b_053" data-name="status1b_053">
  <img class="hidden" src="images/status1b_054.png" alt="status1b_054" data-name="status1b_054">
  <img class="hidden" src="images/status1b_055.png" alt="status1b_055" data-name="status1b_055">
  <img class="hidden" src="images/status1b_056.png" alt="status1b_056" data-name="status1b_056">
  <img class="hidden" src="images/status1b_057.png" alt="status1b_057" data-name="status1b_057">
  <img class="hidden" src="images/status2_046.png" alt="status2_046" data-name="status2_046">
  <img class="hidden" src="images/status2_048.png" alt="status2_048" data-name="status2_048">
  <img class="hidden" src="images/status2_049.png" alt="status2_049" data-name="status2_049">
  <img class="hidden" src="images/status2_050.png" alt="status2_050" data-name="status2_050">
  <img class="hidden" src="images/status2_051.png" alt="status2_051" data-name="status2_051">
  <img class="hidden" src="images/status2_052.png" alt="status2_052" data-name="status2_052">
  <img class="hidden" src="images/status2_053.png" alt="status2_053" data-name="status2_053">
  <img class="hidden" src="images/status2_054.png" alt="status2_054" data-name="status2_054">
  <img class="hidden" src="images/status2_055.png" alt="status2_055" data-name="status2_055">
  <img class="hidden" src="images/status2_056.png" alt="status2_056" data-name="status2_056">
  <img class="hidden" src="images/status2_057.png" alt="status2_057" data-name="status2_057">
  <img class="hidden" src="images/status2_058.png" alt="status2_058" data-name="status2_058">
  <img class="hidden" src="images/xb_a.png" alt="xb_a" data-name="xb_a">
</section>
<section id="soundLoader" class="hidden">
  <audio class="hidden" controls preload="auto" src="sounds/bump0.ogg" data-name="bump0">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/bump1.ogg" data-name="bump1">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/bump2.ogg" data-name="bump2">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/bump3.ogg" data-name="bump3">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/bump4.ogg" data-name="bump4">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/bump5.ogg" data-name="bump5">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/bump_behind0.ogg" data-name="bump_behind0">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/car_hit0.ogg" data-name="car_hit0">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short0.ogg" data-name="engine_short0">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short1.ogg" data-name="engine_short1">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short10.ogg" data-name="engine_short10">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short11.ogg" data-name="engine_short11">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short12.ogg" data-name="engine_short12">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short13.ogg" data-name="engine_short13">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short14.ogg" data-name="engine_short14">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short15.ogg" data-name="engine_short15">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short16.ogg" data-name="engine_short16">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short17.ogg" data-name="engine_short17">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short18.ogg" data-name="engine_short18">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short19.ogg" data-name="engine_short19">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short2.ogg" data-name="engine_short2">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short20.ogg" data-name="engine_short20">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short21.ogg" data-name="engine_short21">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short22.ogg" data-name="engine_short22">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short23.ogg" data-name="engine_short23">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short24.ogg" data-name="engine_short24">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short25.ogg" data-name="engine_short25">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short26.ogg" data-name="engine_short26">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short27.ogg" data-name="engine_short27">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short28.ogg" data-name="engine_short28">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short29.ogg" data-name="engine_short29">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short3.ogg" data-name="engine_short3">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short30.ogg" data-name="engine_short30">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short31.ogg" data-name="engine_short31">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short32.ogg" data-name="engine_short32">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short33.ogg" data-name="engine_short33">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short34.ogg" data-name="engine_short34">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short35.ogg" data-name="engine_short35">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short36.ogg" data-name="engine_short36">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short37.ogg" data-name="engine_short37">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short38.ogg" data-name="engine_short38">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short39.ogg" data-name="engine_short39">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short4.ogg" data-name="engine_short4">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short40.ogg" data-name="engine_short40">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short5.ogg" data-name="engine_short5">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short6.ogg" data-name="engine_short6">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short7.ogg" data-name="engine_short7">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short8.ogg" data-name="engine_short8">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/engine_short9.ogg" data-name="engine_short9">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/explosion0.ogg" data-name="explosion0">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/fastlap0.ogg" data-name="fastlap0">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/final_lap0.ogg" data-name="final_lap0">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/game_complete0.ogg" data-name="game_complete0">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/gobeep0.ogg" data-name="gobeep0">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/hit_grass0.ogg" data-name="hit_grass0">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/overtake0.ogg" data-name="overtake0">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/overtake1.ogg" data-name="overtake1">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/overtake2.ogg" data-name="overtake2">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/overtake3.ogg" data-name="overtake3">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/overtake4.ogg" data-name="overtake4">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/overtake5.ogg" data-name="overtake5">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/skid_loop0.ogg" data-name="skid_loop0">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="sounds/startbeep0.ogg" data-name="startbeep0">Your browser does not support the audio element.</audio>
</section>
<section id="musicLoader" class="hidden">
  <audio class="hidden" controls preload="auto" src="music/ambience.ogg" data-name="ambience">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="music/engines_startline.ogg" data-name="engines_startline">Your browser does not support the audio element.</audio>
  <audio class="hidden" controls preload="auto" src="music/title_theme.ogg" data-name="title_theme">Your browser does not support the audio element.</audio>
</section>

<main>
<h1>leadingedge</h1>

<canvas id="screen">
The game screen appears here if your browser supports the Canvas API.
</canvas>
<section id="controls">
  <button type="button" id="reset">Reset</button>
  <button type="button" id="pause">Pause</button>
</section>

<h2>Attribution</h2>

<p><a href="https://store.rpipress.cc/products/code-the-classics-volume-ii">Code the Classics â€“ Volume 2</a>.</p>

<p>Licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/legalcode">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported</a>.</p>

<h2>Original Python code</h2>

<pre id="original"><code>
# Leading Edge - Code the Classics Volume 2
# Code by Andrew Gillett
# Graphics by Dan Malone
# Music and sound effects by Allister Brimble
# https://github.com/raspberrypipress/Code-the-Classics-Vol2.git
# https://store.rpipress.cc/products/code-the-classics-volume-ii

import pygame, pgzero, pgzrun, math, sys, time, platform
from abc import ABC, abstractmethod
from enum import Enum
from random import randint, uniform, choice
from pygame.math import Vector3, Vector2

# If the game window doesn&#x27;t fit on the screen, you may need to turn off or reduce display scaling in the Windows/macOS settings
# On Windows, you can uncomment the following two lines to fix the issue. It sets the program as &quot;DPI aware&quot;
# meaning that display scaling won&#x27;t be applied to it.
#import ctypes
#ctypes.windll.user32.SetProcessDPIAware()

# Enable this to use Pygame&#x27;s &#x27;gfxdraw&#x27; module for displaying polygons. This is faster in some older versions of Pygame,
# but in the latest version at the time of writing (2.2.0) it may actually be slightly slower than the default drawing
# module. See further down for more performance options
USE_GFXDRAW = False

if USE_GFXDRAW:
    import pygame.gfxdraw

# Check Python version number. sys.version_info gives version as a tuple, e.g. if (3,7,2,&#x27;final&#x27;,0) for version 3.7.2.
# Unlike many languages, Python can compare two tuples in the same way that you can compare numbers.
if sys.version_info &lt; (3,6):
    print(&quot;This game requires at least version 3.6 of Python. Please download it from www.python.org&quot;)
    sys.exit()

# Check Pygame Zero version. This is a bit trickier because Pygame Zero only lets us get its version number as a string.
# So we have to split the string into a list, using &#x27;.&#x27; as the character to split on. We convert each element of the
# version number into an integer - but only if the string contains numbers and nothing else, because it&#x27;s possible for
# a component of the version to contain letters as well as numbers (e.g. &#x27;2.0.dev0&#x27;)
# This uses a Python feature called list comprehension
pgzero_version = [int(s) if s.isnumeric() else s for s in pgzero.__version__.split(&#x27;.&#x27;)]
if pgzero_version &lt; [1,2]:
    print(f&quot;This game requires at least version 1.2 of Pygame Zero. You have version {pgzero.__version__}. Please upgrade using the command &#x27;pip3 install --upgrade pgzero&#x27;&quot;)
    sys.exit()

# For a better frame rate, try width/height of 640x480, or even lower
WIDTH = 960
HEIGHT = 540

TITLE = &quot;Leading Edge&quot;

# Set to True improve frame rate by turning off scenery, drawing unfilled polygons and changing the draw distance
PERFORMANCE_MODE = False

if not PERFORMANCE_MODE:
    SHOW_SCENERY = True
    SHOW_TRACKSIDE = True
    SHOW_RUMBLE_STRIPS = True
    SHOW_YELLOW_LINES = True
    OUTLINE_W = 0                   # Change to 1 for unfilled polygons, which are a bit faster to draw
    VIEW_DISTANCE = 200             # This is in units of number of track pieces, try 60 for a better frame rate, try 2000 for a bad frame rate but impressive draw distance
else:
    SHOW_SCENERY = False
    SHOW_TRACKSIDE = False
    SHOW_RUMBLE_STRIPS = False
    SHOW_YELLOW_LINES = False
    OUTLINE_W = 1                   # Change to 1 for unfilled polygons, which are a bit faster to draw
    VIEW_DISTANCE = 150             # This is in units of number of track pieces, try 60 for a better frame rate, try 2000 for a bad frame rate but impressive draw distance

CLIPPING_PLANE = -0.25          # too close to 0 = frame rate issues (drawing huge polygons which are mostly off-screen), too far = stuff just in front of camera not being drawn
CLIPPING_PLANE_CARS = -0.08     # bring closer to zero to fix occasional flickering of CPU cars when very close to the camera, at the potential cost of frame rate
SCALE_FUNC = pygame.transform.scale     # Which scale function to use - pygame.transform.smoothscale is better quality but slower
MAX_SCENERY_SCALED_WIDTH = WIDTH * 2    # When scaling scenery based on distance from camera, don&#x27;t try to draw anything that would be scaled to wider than this
MAX_CAR_SCALED_WIDTH = WIDTH * 1        # As above but for cars

# Constants for track
SPACING = 1
TRACK_W = 3000
HALF_STRIPE_W = 25
HALF_RUMBLE_STRIP_W = 250
HALF_YELLOW_LINE_W = 80
YELLOW_LINE_DISTANCE_FROM_EDGE = 150
TRACK_COLOUR = (35, 96, 198)
TRACKSIDE_COLOUR_1 = (0, 77, 180)
TRACKSIDE_COLOUR_2 = (50, 77, 170)
STRIPE_COLOUR = (70, 192, 255)
YELLOW_LINE_COL = (0, 161, 88)    # Yes, it&#x27;s actually green, not yellow. It looks yellow because it&#x27;s night.
RUMBLE_COLOUR_1 = (0, 116, 255)
RUMBLE_COLOUR_2 = (0, 58, 135)
SECTION_VERY_SHORT = 25
SECTION_SHORT = 50
SECTION_MEDIUM = 100
SECTION_LONG = 200
LAMP_X = TRACK_W//2 + 300
BILLBOARD_X = TRACK_W//2 + 600

CAMERA_FOLLOW_DISTANCE = 2

# Player car gameplay settings
LOSE_GRIP_SPEED = 50
ZERO_GRIP_SPEED = 100
PLAYER_ACCELERATION_MAX = 20
PLAYER_ACCELERATION_MIN = 10
HIGH_ACCEL_THRESHOLD = 30
CORNER_OFFSET_MULTIPLIER = 5.8      # Higher = harder to corner
STEERING_STRENGTH = 72              # Higher = steering has a stronger effect

# Min/max CPU car target speeds - see also track generation, some track pieces have target speed overrides set
CPU_CAR_MIN_TARGET_SPEED = 40
CPU_CAR_MAX_TARGET_SPEED = 65

NUM_LAPS = 5
NUM_CARS = 20

GRID_CAR_SPACING = 0.55     # How spaced out the cars are on the starting grid

# Half-width and height used during point transform, to save having to calculate them each time
HALF_WIDTH = WIDTH // 2
HALF_HEIGHT = HEIGHT // 2

# Skid sound starts fading in when grip goes below this level
SKID_SOUND_START_GRIP = 0.8

# Debug options
SHOW_TRACK_PIECE_INDEX = False
SHOW_TRACK_PIECE_OFFSETS = False
SHOW_CPU_CAR_SPEEDS = False
SHOW_DEBUG_TEXT = False
SHOW_PROFILE_TIMINGS = False

FIXED_TIMESTEP = 1/60

# These symbols substitute for the controller button images when displaying text.
# The symbols representing these images must be ones that aren&#x27;t actually used themselves, e.g. we don&#x27;t use the
# percent sign in text
SPECIAL_FONT_SYMBOLS = {&#x27;xb_a&#x27;:&#x27;%&#x27;}

# Create a version of SPECIAL_FONT_SYMBOLS where the keys and values are swapped
SPECIAL_FONT_SYMBOLS_INVERSE = dict((v,k) for k,v in SPECIAL_FONT_SYMBOLS.items())

# A black image whose alpha (transparency) we vary, to fade the screen to black during the title screen
fade_to_black_image = pygame.Surface((WIDTH, HEIGHT))

# Class used for timing how long certain bits of code take to run
class Profiler:
    def __init__(self, name=&quot;&quot;):
        self.start_time = time.perf_counter()
        self.name = name

    def get_ms(self):
        endTime = time.perf_counter()
        diff = endTime - self.start_time
        return diff * 1000

    def __str__(self):
        return f&quot;{self.name}: {self.get_ms()}ms&quot;


# Utility functions

def remap(old_val, old_min, old_max, new_min, new_max):
    # todo explain
    return (new_max - new_min)*(old_val - old_min) / (old_max - old_min) + new_min

def remap_clamp(old_val, old_min, old_max, new_min, new_max):
    # todo explain
    # These first two lines are in case new_min and new_max are inverted
    lower_limit = min(new_min, new_max)
    upper_limit = max(new_min, new_max)
    return min(upper_limit, max(lower_limit, remap(old_val, old_min, old_max, new_min, new_max)))

def inverse_lerp(a, b, value):
    # todo explain
    if a != b:
        return min(1, max(0, ((value - a) / (b - a))))
    return 0

def sign(x):
    # Returns 1, 0 or -1 depending on whether number is positive, zero or negative
    if x == 0:
        return 0
    else:
        return -1 if x &lt; 0 else 1

def move_towards(n, target, speed):
    if n &lt; target:
        return min(n + speed, target)
    else:
        return max(n - speed, target)

def format_time(seconds):
    # Return time string in the form &quot;minutes:seconds.milliseconds&quot;
    # 06.3f ensures that we always show 2 digits for the whole part of the seconds
    # 6 refers to the total number of characters including the decimal point
    # We want to display times like &quot;1:05.123&quot; not &quot;1:5.123&quot;
    return f&quot;{int(seconds // 60)}:{seconds % 60:06.3f}&quot;

def get_char_image_and_width(char, font):
    # Return width of given character. ord() gives the ASCII/Unicode code for the given character.
    if char == &quot; &quot;:
        return None, 30
    else:
        if char in SPECIAL_FONT_SYMBOLS_INVERSE:
            image = getattr(images, SPECIAL_FONT_SYMBOLS_INVERSE[char])
        else:
            image = getattr(images, font + &quot;0&quot; + str(ord(char)))
        return image, image.get_width()

TEXT_GAP_X = {&quot;font&quot;:-6, &quot;status1b_&quot;:0, &quot;status2_&quot;:0} # Characters in main font are italic so should overlap a little

def text_width(text, font):
    return sum([get_char_image_and_width(c, font)[1] for c in text]) + TEXT_GAP_X[font] * (len(text)-1)

def draw_text(text, x, y, centre=False, font=&quot;font&quot;):
    if centre:
        x -= text_width(text, font) // 2

    for char in text:
        image, width = get_char_image_and_width(char, font)
        if image is not None:
            screen.blit(image, (x, y))
        x += width + TEXT_GAP_X[font]

class Controls(ABC):
    NUM_BUTTONS = 2

    def __init__(self):
        self.button_previously_down = [False for i in range(Controls.NUM_BUTTONS)]
        self.is_button_pressed = [False for i in range(Controls.NUM_BUTTONS)]

    def update(self):
        # Call each frame to update button status
        for button in range(Controls.NUM_BUTTONS):
            button_down = self.button_down(button)
            self.is_button_pressed[button] = button_down and not self.button_previously_down[button]
            self.button_previously_down[button] = button_down

    @abstractmethod
    def get_x(self):
        # Overridden by subclasses
        pass

    @abstractmethod
    def button_down(self, button):
        # Overridden by subclasses
        pass

    def button_pressed(self, button):
        return self.is_button_pressed[button]

class KeyboardControls(Controls):
    def get_x(self):
        if keyboard.left:
            return -1
        elif keyboard.right:
            return 1
        else:
            return 0

    def button_down(self, button):
        if button == 0:
            return keyboard.lctrl or keyboard.z
        elif button == 1:
            return keyboard.lshift or keyboard.x

class JoystickControls(Controls):
    def __init__(self, joystick):
        super().__init__()
        self.joystick = joystick
        joystick.init() # Not necessary in Pygame 2.0.0 onwards

    def get_axis(self, axis_num):
        if self.joystick.get_numhats() &gt; 0 and self.joystick.get_hat(0)[axis_num] != 0:
            # For some reason, dpad up/down are inverted when getting inputs from
            # an Xbox controller, so need to negate the value if axis_num is 1
            return self.joystick.get_hat(0)[axis_num] * (-1 if axis_num == 1 else 1)

        axis_value = self.joystick.get_axis(axis_num)
        if abs(axis_value) &lt; 0.6:
            # Dead-zone
            return 0
        else:
            return axis_value

    def get_x(self):
        return self.get_axis(0)

    def get_y(self):
        return self.get_axis(1)

    def button_down(self, button):
        # Before checking button, check to make sure that the controller actually has enough buttons
        # There are some weird devices out there which could cause a crash if this check were not present
        if self.joystick.get_numbuttons() &lt;= button:
            print(&quot;Warning: main controller does not have enough buttons!&quot;)
            return False
        return self.joystick.get_button(button) != 0

class Scenery:
    def __init__(self, x, image, min_draw_distance=0, max_draw_distance=VIEW_DISTANCE // 2, scale=1, collision_zones=()):
        self.x = x
        self.image = image
        self.min_draw_distance = min_draw_distance
        self.max_draw_distance = max_draw_distance
        self.scale = scale
        self.collision_zones = collision_zones

    def get_image(self):
        return self.image

class StartGantry(Scenery):
    def __init__(self):
        super().__init__(0, images.start0, min_draw_distance=1, max_draw_distance=VIEW_DISTANCE, scale=4, collision_zones=((-3000,-2400),(2400,3000)))

    def get_image(self):
        # Before we draw, update our billboard image to the appropriate one based on the game&#x27;s start timer
        # Images go from start0 to start4, then we alternate between start4 and start5 every half second
        if game.start_timer &gt; 0:
            index = int(remap(game.start_timer, 4, 0, 0, 4))
        else:
            index = 4 if int(game.timer * 2) % 2 == 0 else 5
        image = &quot;start&quot; + str(index)
        self.image = getattr(images, image)
        return self.image

class Billboard(Scenery):
    def __init__(self, x, image):
        half_width = image.get_width() / 2
        scale = 2
        super().__init__(x, image, scale=scale, collision_zones=((-half_width*scale,half_width*scale),))

class LampLeft(Scenery):
    def __init__(self):
        super().__init__(LAMP_X, images.left_light, scale=2, collision_zones=((350,1200),))

class LampRight(Scenery):
    def __init__(self):
        super().__init__(-LAMP_X, images.right_light, scale=2, collision_zones=((-1200,-350),))

# The track is defined as list of track pieces. A track piece is technically just a line, but a polygon will be
# drawn to connect it to the next piece. So being &#x27;on&#x27; a track piece means being in between that track piece and the
# next one. Each track piece has X and Y offsets, which define how its position differs from the previous piece.
# When the track is drawn, the changes in offset accumulate, so that a series of track pieces with X offsets of 10
# will lead to a curve to the left, from the camera&#x27;s point of view. (Left rather than right because the camera
# points along the negative Z axis)
# The X and Y offsets are the offsets from the previous track piece, so if, for example, track pieces 0 to 5 have an
# X offset of zero and track piece 6 has a very large offset of 1000, it&#x27;s while moving from 5 to 6 that the car
# will start to move to the left
class TrackPiece:
    def __init__(self, scenery=(), offset_x=0, offset_y=0, cpu_max_target_speed=None, col=TRACK_COLOUR, width=TRACK_W):
        self.scenery = scenery
        self.offset_x = offset_x
        self.offset_y = offset_y
        self.cpu_max_target_speed = cpu_max_target_speed
        self.col = col
        self.width = width
        self.cars = []  # Cars currently on this track piece

class TrackPieceStartLine(TrackPiece):
    def __init__(self):
        super().__init__(scenery = [StartGantry()], col=(255,255,255))

class Car:
    def __init__(self, pos, car_letter):
        self.pos = pos
        self.image = f&quot;car_{car_letter}_0_0&quot;
        self.speed = 0
        self.grip = 1
        self.car_letter = car_letter
        self.track_piece = None
        self.tyre_rotation = 0

    def update(self, delta_time):
        self.pos.z -= self.speed * delta_time
        self.update_current_track_piece()
        self.tyre_rotation += delta_time * self.speed * 0.75

    def update_current_track_piece(self):
        # Which track piece are we on?
        current_track_piece = self.track_piece
        idx = game.get_track_piece_for_z(self.pos.z)
        if idx is not None:
            self.track_piece = game.track[idx]
            if self.track_piece is not current_track_piece:
                # Remove myself from the old track piece, add myself to the new one
                if current_track_piece is not None:
                    current_track_piece.cars.remove(self)
                self.track_piece.cars.append(self)

    def update_sprite(self, angle, braking, boost=False):
        if self.speed == 0:
            frame = 0
        elif braking:
            frame = 3
        elif boost:
            frame = int(self.tyre_rotation % 2) + 4
        else:
            frame = int(self.tyre_rotation % 2) + 1
        self.image = f&quot;car_{self.car_letter}_{angle}_{frame}&quot;


class CPUCar(Car):
    def __init__(self, pos, accel, speed):
        super().__init__(pos, choice((&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;)))

        # CPU cars accelerate faster than player but have a lower top speed
        self.accel = PLAYER_ACCELERATION_MAX * accel
        self.target_speed = speed
        self.target_x = pos.x

        # Set based on track curvature, so we can display an angled variant of the car sprite
        self.steering = 0

        self.change_speed_timer = uniform(2, 4)

    def update(self, delta_time):
        if game.race_complete:
            self.target_speed = game.player_car.speed

        self.speed = move_towards(self.speed, self.target_speed, self.accel * delta_time)
        self.pos.x = move_towards(self.pos.x, self.target_x, 400 * delta_time)

        super().update(delta_time)

        track_piece_idx, _ = game.get_first_track_piece_ahead(self.pos.z)
        if track_piece_idx is not None:
            self.steering = game.track[track_piece_idx].offset_x

        # Every few seconds we&#x27;ll change target speed by a random amount, but upwards on average, so that slow cars
        # have a chance to catch up, and so that we can see CPU cars overtaking each other
        self.change_speed_timer -= delta_time
        if self.change_speed_timer &lt;= 0 and not game.race_complete:
            self.target_speed += uniform(-4, 6)
            self.target_speed = min(max(self.target_speed, CPU_CAR_MIN_TARGET_SPEED), CPU_CAR_MAX_TARGET_SPEED)

            # If we&#x27;re on a sharp corner and speed is above a certain level, reduce target speed
            if track_piece_idx is not None:
                target_speed_override = game.track[track_piece_idx].cpu_max_target_speed
                if target_speed_override is not None and self.target_speed &gt; target_speed_override:
                    # Make it slightly random
                    self.target_speed = uniform(target_speed_override-3, target_speed_override)

            # Also change target X pos to a random value
            # Ensure not too close to values for nearby cars, to avoid cars driving through each other

            def is_target_x_too_close_to_nearby_cars():
                for car in game.cars:
                    if car is not self and abs(self.pos.z - car.pos.z) &lt; 20 and abs(self.target_x - car.pos.x) &lt; 300:
                        return True
                return False

            # Limit number of attempts to ensure no chance of infinite loop
            for attempt in range(0,20):
                self.target_x = uniform(-1000, 1000)
                if not is_target_x_too_close_to_nearby_cars():
                    break

            # Reset timer
            self.change_speed_timer = uniform(2, 4)

class PlayerCar(Car):
    def __init__(self, pos, controls):
        super().__init__(pos, &#x27;a&#x27;)
        self.pos = pos
        self.controls = controls
        self.offset_x_change = 0
        self.resetting = False
        self.explode_timer = None
        self.last_checkpoint_idx = None
        self.lap = 1
        self.lap_time = 0
        self.race_time = 0
        self.fastest_lap = None
        self.last_lap_was_fastest = False
        self.braking = False

        # Load engine and skid sounds. These are not played with Game.play_sound as they require custom behaviour.
        # Enclosed in a try/except section to deal with the case where the sound files can&#x27;t be loaded, which can
        # occur if there is no sound hardware or sound is disabled
        try:
            self.engine_sounds = [getattr(sounds, &quot;engine_short&quot; + str(i)) for i in range(40)]
            self.skid_sound = sounds.skid_loop0
        except Exception:
            self.engine_sounds = []
            self.skid_sound = None

        self.current_engine_sound = None
        self.current_engine_sound_idx = -1
        self.update_engine_sound()

        self.skid_sound_playing = False

        self.grass_sound_repeat_timer = 0
        self.on_grass = False

        # Last known position in the race, indexed from 0 - used to decide when to play overtaking sounds
        self.prev_position = NUM_CARS - 1

    def stop_engine_sound(self):
        if self.current_engine_sound is not None:
            try:
                self.current_engine_sound.stop()
            except Exception:
                # Ignore errors - e.g. no sound hardware, or sound mixer has been shut down
                pass

    def update(self, delta_time):
        if not game.race_complete:
            self.lap_time += delta_time
            self.race_time += delta_time

        self.grass_sound_repeat_timer -= delta_time

        self.update_engine_sound()

        # Play overtaking sounds? See if our position in the race has changed since last frame
        current_position = game.cars.index(self)
        if current_position != self.prev_position:
            # Only play sound if speed difference is high enough
            if abs(self.speed - game.cars[self.prev_position].speed) &gt; 4:
                game.play_sound(&quot;overtake&quot;,6)

            self.prev_position = current_position

        if self.resetting:
            if self.explode_timer is not None:
                self.explode_timer += 1
                if self.explode_timer &gt; 31:
                    self.explode_timer = None
            else:
                # Reset player to centre of track over about 2 seconds
                self.pos.x = move_towards(self.pos.x, 0, 2000 * delta_time)
                self.resetting = self.pos.x != 0

        x_move = 0
        accel = 0

        if not self.resetting:
            # Not resetting - do normal movement &amp; controls

            self.braking = False

            # Only get control inputs if race is not complete
            if not game.race_complete:
                self.controls.update()
                if self.controls.button_down(0):
                    accel = PLAYER_ACCELERATION_MAX if self.speed &lt; HIGH_ACCEL_THRESHOLD else PLAYER_ACCELERATION_MIN
                    self.speed += accel * delta_time
                elif self.controls.button_down(1):
                    # Brake
                    self.braking = True
                    self.speed = max(0, self.speed - delta_time * 10)

            # Apply drag in a frame-rate independent way
            drag_factor = 0.9975
            if self.on_grass:
                # More drag on grass
                drag_factor -= 0.0025

            # Apply drag to speed. ** = power, e.g. 3 ** 5 is 3 to the power of 5
            # Check out this superb video which explains the uses and misuses of delta times, including more advanced
            # uses as seen in this case: https://www.youtube.com/watch?v=yGhfUcPjXuE
            self.speed *= drag_factor ** (delta_time / (1 / 60))

            # If we&#x27;re going round a corner, shift X pos so that failing to steer will take you off the track
            # This is necessary because in this game, the corners are just illusions!
            if self.offset_x_change != 0:
                # We also set self.grip to less than 1 if we&#x27;re cornering at high speed (but only if we&#x27;re steering
                # in same direction as corner)
                if self.speed &gt; LOSE_GRIP_SPEED and sign(self.get_x_input()) == -sign(self.offset_x_change):
                    self.grip = remap_clamp(self.speed, LOSE_GRIP_SPEED, ZERO_GRIP_SPEED, 1, 0)
                else:
                    self.grip = 1

                # Apply corner offset - grip will be used to alter steering movement in Car.update
                # We don&#x27;t multiply by delta_time here as offset_x_change is partly based on the total amount of forward
                # motion that has taken place since the previous frame, which already takes delta_time into account
                # We don&#x27;t do this if the race is complete - just let car go around the corners with no steering needed
                if not game.race_complete:
                    self.pos.x -= self.offset_x_change * CORNER_OFFSET_MULTIPLIER

            else:
                # Not going around a corner
                self.grip = 1

            # Get track piece we were on before forward motion was applied
            previous_track_piece_idx, _ = game.get_first_track_piece_ahead(self.pos.z)

            # Apply steering
            if self.speed &gt; 0 and not game.race_complete:
                x_move = self.get_x_input() * self.speed * STEERING_STRENGTH * self.grip * delta_time
                self.pos.x -= x_move

            # Call parent (Car) update method, which includes applying motion
            super().update(delta_time)

            # Check for collisions with other cars
            for car in game.cars:
                if car is not self:
                    # Note - axes are not uniform in scale (1 unit in X axis is much smaller than 1 unit in Z axis),
                    # so we can&#x27;t do a normal distance calculation.
                    # Instead we just check X and Z differences separately (Y is irrelevant as cars are always
                    # on the ground)
                    vec = self.pos - car.pos
                    COLLIDE_FRONT_DISTANCE_Z = 0.6
                    COLLIDE_BACK_DISTANCE_Z = 1.2
                    if abs(vec.x) &lt; 260 and vec.z &lt; COLLIDE_FRONT_DISTANCE_Z and vec.z &gt; -COLLIDE_BACK_DISTANCE_Z:
                        midpoint = (self.pos.z - car.pos.z) / 2 + car.pos.z
                        # Which side did we collide on?
                        # An alternative way to do this would be to use the speed difference, e.g. if player speed
                        # is faster, we hit the car in front
                        if abs(vec.z) &lt; 0.2:
                            # Side collision
                            self.pos.x += sign(vec.x) * 50
                            car.pos.x -= sign(vec.x) * 50

                        elif vec.z &gt; 0:
                            # Colliding with the back of the car in front
                            self.speed = max(car.speed - 3, 0)
                            car.speed = max(car.speed, self.speed + 3)
                            car.target_speed = car.speed

                            # Shift us back and other car forward so we&#x27;re not longer overlapping
                            self.pos.z = midpoint + COLLIDE_FRONT_DISTANCE_Z * 0.6
                            car.pos.z = midpoint - COLLIDE_FRONT_DISTANCE_Z * 0.6

                            game.play_sound(&quot;bump&quot;, 6)

                        else:
                            # Car behind collided with us - get a speed boost
                            self.speed = max(self.speed, car.speed + 3)
                            car.speed = max(self.speed - 3, 0)

                            # Shift other car back and us forward so we&#x27;re not longer overlapping
                            self.pos.z = midpoint - COLLIDE_BACK_DISTANCE_Z * 0.6
                            car.pos.z = midpoint + COLLIDE_BACK_DISTANCE_Z * 0.6

                            game.play_sound(&quot;bump_behind&quot;)

            # Check for collisions with scenery, driving on grass and passing a checkpoint
            track_piece_idx, _ = game.get_first_track_piece_ahead(self.pos.z)
            if track_piece_idx is not None:
                track_piece = game.track[track_piece_idx]

                for scenery in track_piece.scenery:
                    for collision_zone in scenery.collision_zones:
                        zone_left = scenery.x + collision_zone[0]
                        zone_right = scenery.x + collision_zone[1]
                        if zone_left &lt; self.pos.x &lt; zone_right:
                            self.speed = 0
                            self.resetting = True
                            self.explode_timer = 0  # Start explosion animation
                            game.play_sound(&quot;explosion&quot;)

                # Are we on, or have we passed, a checkpoint?
                for i in range(previous_track_piece_idx, track_piece_idx+1):
                    if isinstance(game.track[i], TrackPieceStartLine):
                        # It&#x27;s a checkpoint. If it&#x27;s the first one, ignore it (passing the start line at the start of
                        # the race is not of interest). If we&#x27;ve already dealt with this checkpoint, ignore it.
                        # Otherwise update lap count and lap time
                        if self.last_checkpoint_idx is not None and self.last_checkpoint_idx != i:
                            self.lap += 1

                            # Was this the fastest lap?
                            if self.fastest_lap is None or self.lap_time &lt; self.fastest_lap:
                                self.fastest_lap = self.lap_time
                                self.last_lap_was_fastest = True
                                game.play_sound(&quot;fastlap&quot;)
                            else:
                                self.last_lap_was_fastest = False

                            # Play final lap sound effect?
                            if self.lap == NUM_LAPS:
                                game.play_sound(&quot;final_lap&quot;)

                            # Set lap time back to 0 for new lap
                            self.lap_time = 0

                        self.last_checkpoint_idx = i

                # Are we on the grass?
                if abs(self.pos.x) + 100 &gt; track_piece.width / 2:
                    self.on_grass = True
                    if self.grass_sound_repeat_timer &lt;= 0:
                        game.play_sound(&quot;hit_grass&quot;)
                        self.grass_sound_repeat_timer = 0.15

                    # Are we way too far off the track? Reset if so
                    if abs(self.pos.x) &gt; 6000:
                        self.speed = 0
                        self.resetting = True
                else:
                    self.on_grass = False

            # End of &quot;if not self.resetting&quot; block

        # Depending on grip, turn skid sound on/off or vary volume
        if self.skid_sound is not None:
            # Determine volume to play skid sound at
            if self.resetting or self.grip &gt;= SKID_SOUND_START_GRIP or self.get_x_input() == 0:
                volume = 0

            else:
                volume = remap_clamp(self.grip, SKID_SOUND_START_GRIP, 0.5, 0, 1)

                # Scale volume based on track curvature - higher volume for tighter corners
                if track_piece_idx is not None:
                    track_piece = game.track[track_piece_idx]
                    volume *= remap_clamp(abs(track_piece.offset_x), 0, 15, 0, 1)

            if volume &gt; 0:
                if not self.skid_sound_playing:
                    self.skid_sound.play(loops=-1, fade_ms=100)  # Loop indefinitely
                    self.skid_sound_playing = True

                self.skid_sound.set_volume(volume)
            else:
                self.skid_sound_playing = False
                self.skid_sound.fadeout(250)

        # Set sprite
        if self.explode_timer is not None:
            self.image = f&quot;explode{self.explode_timer//2:02}&quot;
        else:
            direction = 0
            if x_move &lt; 0:
                direction = -1
            elif x_move &gt; 0:
                direction = 1
            boost = accel &gt; 0 and self.speed &lt; HIGH_ACCEL_THRESHOLD and self.speed &gt; 0
            self.update_sprite(direction, self.braking, boost)

    def update_engine_sound(self):
        sound_index = min(int(self.speed * 0.6), len(self.engine_sounds) - 1)
        if sound_index != self.current_engine_sound_idx:
            self.current_engine_sound_idx = sound_index
            old_sound = self.current_engine_sound
            self.current_engine_sound = self.engine_sounds[sound_index]
            self.current_engine_sound.set_volume(0.3)

            # Stop the old sound and play the new sound - ignore errors (e.g. no sound hardware)
            try:
                if old_sound is not None:
                    old_sound.fadeout(150)
                self.current_engine_sound.play(loops=-1, fade_ms=100)
            except Exception:
                pass

    def get_x_input(self):
        return self.controls.get_x()

    def set_offset_x_change(self, value):
        self.offset_x_change = value


def generate_scenery(track_i, image=images.billboard00, interval=40, lamps=True):
    if track_i % interval == 0:
        # Billboards
        return [Billboard(BILLBOARD_X, image), Billboard(-BILLBOARD_X, image)]
    elif lamps and track_i % 30 == 0:
        # Lamps
        return [LampLeft(), LampRight()]
    else:
        return []

def make_track():
    # Each track piece in the list represents a line with a particular width, with optional attached scenery.
    # When the track is drawn, we draw a polygon for each track piece, connecting this line with the line of the
    # previous track piece.
    track = []
    for lap in range(NUM_LAPS + 1):
        track.extend([TrackPiece(scenery=generate_scenery(i,images.billboard02)) for i in range(15)])

        # Start gantry
        track.append(TrackPieceStartLine())

        track.extend([TrackPiece() for i in range(SECTION_SHORT)])

        # Because the camera is pointing down the negative Z axis, negative/positive X mean right/left from
        # camera&#x27;s perspective

        # Mild right turn followed by short straight
        track.extend([TrackPiece(offset_x=-4, offset_y=0, scenery=generate_scenery(i)) for i in range(SECTION_MEDIUM)])
        track.extend([TrackPiece(scenery=generate_scenery(i,images.billboard01)) for i in range(SECTION_SHORT)])

        # Slight downward slope, going into moderate right hand turn
        track.extend([TrackPiece(offset_x=0, offset_y=-1, scenery=generate_scenery(i)) for i in range(SECTION_VERY_SHORT)])
        track.extend([TrackPiece(offset_x=0, offset_y=-2, scenery=generate_scenery(i)) for i in range(SECTION_VERY_SHORT)])
        track.extend([TrackPiece(offset_x=-2, offset_y=-1, scenery=generate_scenery(i)) for i in range(SECTION_VERY_SHORT)])
        track.extend([TrackPiece(offset_x=-5, offset_y=0, scenery=generate_scenery(i,images.billboard03)) for i in range(SECTION_VERY_SHORT)])
        track.extend([TrackPiece(offset_x=-10, offset_y=0, scenery=generate_scenery(i,images.billboard03)) for i in range(SECTION_MEDIUM)])

        # Short straight
        track.extend([TrackPiece(scenery=generate_scenery(i)) for i in range(SECTION_SHORT)])

        # Medium-sharp turn left, slight upward slope
        track.extend([TrackPiece(offset_x=13, offset_y=1, scenery=generate_scenery(i, images.arrow_left, interval=10)) for i in range(SECTION_MEDIUM)])

        track.extend([TrackPiece(offset_x=0, offset_y=0, scenery=generate_scenery(i,images.billboard02)) for i in range(SECTION_MEDIUM)])

        # Small hill
        track.extend([TrackPiece(offset_x=0, offset_y=2, scenery=generate_scenery(i,images.billboard02)) for i in range(SECTION_MEDIUM)])

        # Slightly down and to the right
        track.extend([TrackPiece(offset_x=-3, offset_y=-1, scenery=generate_scenery(i,images.billboard01)) for i in range(SECTION_LONG)])

        # Crazy downward curve
        track.extend([TrackPiece(offset_x=0, offset_y=-4, scenery=generate_scenery(i)) for i in range(SECTION_MEDIUM)])

        # Upward slope
        track.extend([TrackPiece(offset_x=0, offset_y=2, scenery=generate_scenery(i,images.billboard03)) for i in range(SECTION_LONG)])

        # Turn to left and up, gradually increasing curve
        for j in range(1,10):
            track.extend([TrackPiece(offset_x=j, offset_y=j, scenery=generate_scenery(i)) for i in range(SECTION_VERY_SHORT)])

        # Downward curve, increasing then decreasing in intensity
        for j in range(1,10):
            track.extend([TrackPiece(offset_x=0, offset_y=-j, scenery=generate_scenery(i)) for i in range(SECTION_VERY_SHORT)])

        # straight with chevron billboards at end, CPU cars will slow down in this section
        track.extend([TrackPiece(cpu_max_target_speed=60, scenery=[]) for i in range(SECTION_MEDIUM)])
        track.extend([TrackPiece(cpu_max_target_speed=58, scenery=generate_scenery(i, images.arrow_right, interval=10, lamps=False)) for i in range(SECTION_SHORT)])
        track.extend([TrackPiece(cpu_max_target_speed=58, scenery=generate_scenery(i, images.arrow_right, interval=10, lamps=False)) for i in range(SECTION_SHORT)])

        # sharp turn right, easing off slightly at end
        track.extend([TrackPiece(offset_x=-15, cpu_max_target_speed=55, scenery=generate_scenery(i, images.arrow_right, interval=10, lamps=False)) for i in range(SECTION_SHORT)])
        track.extend([TrackPiece(offset_x=-13, cpu_max_target_speed=57, scenery=generate_scenery(i, images.arrow_right, interval=10, lamps=False)) for i in range(SECTION_SHORT)])
        track.extend([TrackPiece(offset_x=-11, offset_y=0, scenery=generate_scenery(i)) for i in range(SECTION_SHORT)])
        track.extend([TrackPiece(offset_x=-9, offset_y=0, scenery=generate_scenery(i)) for i in range(SECTION_SHORT)])

        # straight
        track.extend([TrackPiece(offset_x=0, offset_y=0, scenery=generate_scenery(i)) for i in range(SECTION_MEDIUM)])

        # cosine hills
        track.extend([TrackPiece(offset_y=math.cos(i/20) * 5, scenery=generate_scenery(i)) for i in range(SECTION_LONG)])

        # Mild upward slope - the purpose is to reset the Y scrolling of the background so it roughly matches the
        # background position at the start of the lap
        track.extend([TrackPiece(offset_x=0, offset_y=0.25, scenery=generate_scenery(i,images.billboard03)) for i in range(SECTION_LONG)])

        # short straight
        track.extend([TrackPiece(offset_x=0, offset_y=0, scenery=generate_scenery(i,images.billboard03)) for i in range(SECTION_SHORT)])

    return track

class Game:
    def __init__(self, controls=None):
        self.track = make_track()

        # We only create a player car (in setup_cars) when there is a controls object
        self.player_car = None
        self.camera_follow_car = None

        self.setup_cars(controls)

        self.camera = Vector3(0, 400, 0)

        self.background = images.background
        self.bg_offset = Vector2(-self.background.get_width() // 2, 30)

        self.first_frame = True
        self.on_screen_debug_strs = []
        self.frame_counter = 0
        self.timer = 0
        self.race_complete = False
        self.time_up = False

        if self.player_car is not None:
            self.start_timer = 3.999
            play_music(&quot;engines_startline&quot;)
        else:
            # Race starts immediately on title screen
            self.start_timer = 0

    def setup_cars(self, controls):
        self.cars = []  # Will be kept in sorted order of position
        for i in range(NUM_CARS):
            z = -3 - i * GRID_CAR_SPACING
            x = -400 if i % 2 == 0 else 400
            if i == 0 and controls is not None:
                # Don&#x27;t create player car on title screen
                self.player_car = PlayerCar(Vector3(x, 0, z), controls)
                self.cars.append(self.player_car)
            else:
                target_speed = remap(i, 0, NUM_CARS - 1, CPU_CAR_MIN_TARGET_SPEED, CPU_CAR_MAX_TARGET_SPEED)
                accel = remap(i, 0, NUM_CARS - 1, 1.5, 2)
                self.cars.append(CPUCar(Vector3(x, 0, z), speed=target_speed, accel=accel))

        if self.player_car is not None:
            self.camera_follow_car = self.player_car
        else:
            self.camera_follow_car = self.cars[0]

    def update(self, delta_time):
        self.timer += delta_time
        self.frame_counter += 1

        # Race start sequence
        if self.start_timer &gt; 0:
            # Ensure cars are added to the appropriate track piece&#x27;s car list, so that
            # they&#x27;re displayed during the start countdown (during which time their update is not called)
            for car in self.cars:
                car.update_current_track_piece()
            timer_old = self.start_timer
            self.start_timer = max(0, self.start_timer - delta_time)
            # Every second of the countdown, make a sound effect
            if self.start_timer == 0:
                # Go!
                # Ambience is stereo so is treated as music
                play_music(&quot;ambience&quot;)
                game.play_sound(&quot;gobeep&quot;)

            elif int(timer_old) != int(self.start_timer):
                game.play_sound(&quot;startbeep&quot;)

        old_camera_z = self.camera.z
        prev_ahead, _ = self.get_first_track_piece_ahead(old_camera_z)

        # If race has started, update all cars
        if self.start_timer == 0:
            for car in self.cars:
                car.update(delta_time)

        # Is the race complete?
        if not self.race_complete and self.player_car is not None :
            # End the game if lap time reaches 4 mins
            # This serves two purposes:
            # 1) Prevent lap time text from overflowing its area (would happen after 10 mins)
            # 2) If the game is being demoed in public, and someone starts playing and then leaves before finishing
            #    a race, the game will eventually end so that the next player can start a fresh race without having
            #    to quit and re-run the game
            # Also allow player to end the game by pressing Escape
            if self.player_car.lap_time &gt;= 60 * 4 or keyboard.escape:
                stop_music()
                self.time_up = True
                self.race_complete = True

            elif self.player_car.lap &gt; NUM_LAPS:
                stop_music()
                self.race_complete = True

                self.play_sound(&quot;game_complete&quot;)

            # Sort cars in the list based on race positions
            self.cars.sort(key=lambda car: car.pos.z)

        # Update camera position to follow player car
        self.camera.x = self.camera_follow_car.pos.x
        self.camera.z = self.camera_follow_car.pos.z + CAMERA_FOLLOW_DISTANCE

        # As camera moves around corners, add to bg_offset and shift car X position so that steering is required on corners

        # Get the new camera pos and determine which track piece it&#x27;s on. The logic is different depending on whether
        # the position change goes from one track piece to the next, or is within one track piece
        new_camera_z = self.camera.z
        new_ahead, _ = self.get_first_track_piece_ahead(new_camera_z)

        # We need to deal with not just interpolating during movement within one track piece, but also when we pass the
        # boundary of a track piece.
        # We need to know how far the camera has travelled since the start of the frame and work out which portion of the
        # movement covers which track piece.
        # It&#x27;s also possible for the movement to be across more than two track pieces.

        # Example
        # track i   z   offset_x
        # 5         -5  0
        # 6         -6  1000
        # 7         -7  0

        # Car start Z = -5      First track piece ahead = 5 (offset 0)
        # Car end Z = -5.5      First track piece ahead = 6 (offset 1000)
        # Offset change = 500

        # Car start Z = -5.4    First track piece ahead = 6 (offset 1000)
        # Car end Z = -5.5      First track piece ahead = 6 (offset 1000)
        # Offset change = 100

        # Car start Z = -5      First track piece ahead = 5 (offset 0)
        #                       Spans whole of piece 6 (offset 1000)
        # Car end Z = -6.1      First track piece ahead = 7 (offset 0)
        # Offset change = 1000

        # Car start Z = -5.001  First track piece ahead = 6 (offset 1000)
        # Car end Z = -6.1      First track piece ahead = 7 (offset 0)
        # Offset change = 999.9

        # Get distance from here to next SPACING increment or new camera z, whichever is a smaller change (higher number)
        # Ignore if camera moved backwards (debug camera only), or the camera is before the start of the track
        # Don&#x27;t do this on first frame, as camera won&#x27;t have its correct initial Z position at the beginning of the frame
        distance = old_camera_z - new_camera_z
        offset_change = Vector2(0, 0)
        if distance &gt; 0 and not self.first_frame and prev_ahead &gt;= 0 and new_ahead &gt;= 0:
            old_z_next_spacing_boundary = (old_camera_z // SPACING) * SPACING
            new_z_prev_spacing_boundary = ((new_camera_z // SPACING) * SPACING) + SPACING
            prev_track = self.track[prev_ahead]
            new_track = self.track[new_ahead]
            if new_ahead &gt; prev_ahead:
                # Movement touches at least two track pieces
                # Figure out how much of the movement was within the old and new track pieces, plus whether there
                # are any intermediate track pieces between them (whose offsets will be fully applied)

                # What proportion of the old and new track pieces have we covered?
                distance_first = old_camera_z - old_z_next_spacing_boundary
                distance_last = new_z_prev_spacing_boundary - new_camera_z
                fraction_first = distance_first / SPACING
                fraction_last = distance_last / SPACING

                # assert stops the program with an AssertionError if the specified condition is false. Both fractions
                # should always be between zero and one, and if they aren&#x27;t then we want to know about it. This assertion
                # may trigger with very low values of SPACING, possibly due to floating point inaccuracy.
                assert (0 &lt;= fraction_first &lt;= 1 and 0 &lt;= fraction_last &lt;= 1)

                offset_change = Vector2(prev_track.offset_x, prev_track.offset_y) * fraction_first \
                                + Vector2(new_track.offset_x, new_track.offset_y) * fraction_last

                # If difference between prev_ahead and new_ahead is more than 1, that means the movement involves
                # three or more track pieces. We will have passed 100% of each of the in-between track pieces, so we
                # fully add their offsets
                if new_ahead - prev_ahead &gt; 1:
                    for i in range(prev_ahead + 1, new_ahead):
                        piece = self.track[i]
                        offset_change += Vector2(piece.offset_x, piece.offset_y)

            else:
                # Movement was just within one track piece
                fraction = distance / SPACING
                assert(0 &lt;= fraction &lt;= 1)
                offset_change = Vector2(prev_track.offset_x, prev_track.offset_y) * fraction

            # Shift background by the calculated offset
            self.bg_offset += offset_change

            # Keep bg_offset.x within the range -backgroundwidth to +backgroundwidth
            while self.bg_offset.x &lt; -self.background.get_width():
                self.bg_offset.x += self.background.get_width()
            while self.bg_offset.x &gt; self.background.get_width():
                self.bg_offset.x -= self.background.get_width()

        # Shift player car&#x27;s X offset - this means the car will go off the track if you go around a corner without
        # steering. Without this, the car would magically stick to the track as if the corner wasn&#x27;t there - because
        # the curvature is really just a visual effect!
        if self.player_car is not None:
            self.player_car.set_offset_x_change(offset_change.x)

        # This deals with moving the background when the camera is moving backwards, which will only happen if the
        # player uses the down arrow key debug mode
        if new_ahead &lt; prev_ahead:
            self.bg_offset.x -= self.track[prev_ahead].offset_x
            self.bg_offset.y -= self.track[prev_ahead].offset_y

        self.first_frame = False

    def draw(self):
        # Fill background with single colour
        # We use a different background colour depending on the Y offset of the background image, because
        # the top and bottom of that image are different colours
        if self.bg_offset.y &gt; 0:
            screen.fill( (0,20,117) )
        else:
            screen.fill( (0,77,180) )

        # Profiling times
        times = {&quot;scenery_scale&quot;: 0, &quot;car_scale&quot;: 0, &quot;prepare_draw_cars&quot;: 0}

        # Draw background
        # Need to draw either one or two backgrounds - second copy is for wrapping (when bg_offset.x changes enough that
        # we&#x27;d see the edge of the image)
        profile_bg = Profiler()
        self.on_screen_debug_strs.append(str(self.bg_offset))
        screen.blit(self.background, self.bg_offset)
        if self.bg_offset.x &gt; 0:
            screen.blit(self.background, self.bg_offset - Vector2(self.background.get_width(), 0))
        if self.bg_offset.x + self.background.get_width() &lt; WIDTH:
            screen.blit(self.background, self.bg_offset + Vector2(self.background.get_width(), 0))
        times[&quot;bg&quot;] = profile_bg.get_ms()

        def transform(point_v3, w=None, h=None, clipping_plane=CLIPPING_PLANE):
            # This local function receives a point as a Vector3 and transforms it into a Vector2 point in screen space
            # When called for a car or scenery item, w and h are specified, referring to the size of the original
            # sprite, so it also calculates and returns the scaled width and height, based on the distance from the camera
            newpoint = point_v3 - self.camera
            if newpoint.z &gt; clipping_plane:
                return None if w is None else (None, None, None)

            # Apply perspective and centre on the screen
            point_v2 = pygame.math.Vector2((newpoint.x / newpoint.z) + HALF_WIDTH,
                                           (newpoint.y / newpoint.z) + HALF_HEIGHT)

            if w is None:
                return point_v2
            else:
                return point_v2, w / -newpoint.z, h / -newpoint.z

        # offset and offset_delta keep track of the cumulative changes in track offsets (X and Y - Z remains as 0), so
        # that each track piece is drawn in the correct position
        offset = Vector3(0, 0, 0)
        offset_delta = Vector3(0, 0, 0)

        # Tuples of pairs of Vector2s storing screen positions of left and right edges of the track, central
        # stripes and left/right rumble strips. We remember them so they don&#x27;t need to be recalculated when joining up
        # a track piece or stripe with the previous one
        prev_track_screen = None
        prev_stripe_screen = None
        prev_rumble_left_outer_screen = None
        prev_rumble_right_outer_screen = None

        # Instead of drawing track pieces etc as we come across them, we store draw calls in this list. Then we once
        # we&#x27;ve finished going through track pieces, we execute the draw calls in reverse order, so that track
        # pieces, cars and scenery in the distance are drawn before things which are closer
        draw_list = []

        def add_to_draw_list(drawcall, type=&quot;?&quot;):
            draw_list.append((drawcall, type))

        is_first_track_piece_ahead = True

        prof_track = Profiler(&quot;track&quot;)

        # Get index of first track piece that starts at or just in front of the camera Z position
        # This means the track piece we&#x27;re currently part-way through won&#x27;t be displayed, but that doesn&#x27;t matter
        # as it would be off the bottom of the camera.
        first_track_piece_idx, current_piece_z = self.get_first_track_piece_ahead(self.camera.z)

        # Index of the track piece that we&#x27;re drawing, relative to first_track_piece_idx
        track_ahead_i = 0

        # At the start of the loop body below, we subtract SPACING from current_piece_z. Therefore we must add SPACING
        # before the loop so that current_piece_z is correct for the first track piece.
        current_piece_z += SPACING

        # Go through each track piece ahead
        for i in range(first_track_piece_idx, len(self.track)):
            # Stop when we&#x27;ve displayed VIEW_DISTANCE number of track pieces
            track_ahead_i += 1
            if track_ahead_i &gt; VIEW_DISTANCE:
                break

            track_piece = self.track[i]
            current_piece_z -= SPACING

            # Because the camera is pointing down the negative Z axis, negative/positive X mean right/left from
            # camera&#x27;s perspective
            left = Vector3(track_piece.width / 2, 0, current_piece_z)
            right = Vector3(-track_piece.width / 2, 0, current_piece_z)

            # Interpolate for X offset between first and next track piece. Without this, going around corners would
            # look very juddery
            if is_first_track_piece_ahead:
                # Get fraction between this and next
                # Current track piece is actually the first track piece IN FRONT of Z
                # And next is the one after that
                # So to find the fraction we need to add spacing
                adjusted_camera_z = self.camera.z - SPACING
                fraction = inverse_lerp(current_piece_z - SPACING, current_piece_z, adjusted_camera_z)
                offset_delta = Vector3(fraction * track_piece.offset_x, fraction * track_piece.offset_y, 0)
            else:
                offset_delta += Vector3(track_piece.offset_x, track_piece.offset_y, 0)

            is_first_track_piece_ahead = False

            offset += offset_delta

            left += offset
            right += offset

            # Calculate screen positions of track boundaries
            left_screen = transform(left)
            right_screen = transform(right)

            # Calculate screen pos of central stripe
            # Always work out stripe points even for pieces which don&#x27;t need them, because the next track piece may
            # make use of the calculated points to connect up to
            stripe_left = Vector3(HALF_STRIPE_W, 0, current_piece_z) + offset
            stripe_right = Vector3(-HALF_STRIPE_W, 0, current_piece_z) + offset
            stripe_left_screen = transform(stripe_left)
            stripe_right_screen = transform(stripe_right)

            # Calculate screen pos of outer parts of left/right rumble strips (can just use left/right track positions
            # for inner part that touches track)
            rumble_strip_left_outer = left + Vector3(HALF_RUMBLE_STRIP_W, 0, 0)
            rumble_strip_right_outer = right - Vector3(HALF_RUMBLE_STRIP_W, 0, 0)
            rumble_strip_left_outer_screen = transform(rumble_strip_left_outer)
            rumble_strip_right_outer_screen = transform(rumble_strip_right_outer)

            # Calculate screen pos of left and right yellow lines, which are just inside the outer edges of the track
            yellow_line_left_outer = left - Vector3(YELLOW_LINE_DISTANCE_FROM_EDGE, 0, 0)
            yellow_line_left_inner = yellow_line_left_outer - Vector3(HALF_YELLOW_LINE_W, 0, 0)
            yellow_line_right_outer = right + Vector3(YELLOW_LINE_DISTANCE_FROM_EDGE, 0, 0)
            yellow_line_right_inner = yellow_line_right_outer + Vector3(HALF_YELLOW_LINE_W, 0, 0)
            yellow_line_left_outer_screen = transform(yellow_line_left_outer)
            yellow_line_left_inner_screen = transform(yellow_line_left_inner)
            yellow_line_right_outer_screen = transform(yellow_line_right_outer)
            yellow_line_right_inner_screen = transform(yellow_line_right_inner)

            # Only draw if both points are in front of clipping plane
            if left_screen is not None and right_screen is not None:
                # To draw, there must be a previous track piece that we can connect to
                if prev_track_screen is not None:
                    def any_on_screen(points):
                        # point[1] gets Y for both tuple pair and Vector2
                        on_screen = [point for point in points if point[1] &lt; HEIGHT]
                        return any(on_screen)

                    def draw_polygon(points, col):
                        if USE_GFXDRAW:
                            if OUTLINE_W == 0:
                                pygame.gfxdraw.filled_polygon(screen.surface, points, col)
                            else:
                                pygame.gfxdraw.polygon(screen.surface, points, col)
                        else:
                            pygame.draw.polygon(screen.surface, col, points, OUTLINE_W)

                    def draw_points(points, col, id):
                        if any_on_screen(points):
                            add_to_draw_list( lambda col=col, points=points: draw_polygon(points, col), id)

                    # Draw stripe (3m on/off)
                    if i // 3 % 2 == 0:
                        points = (stripe_left_screen, stripe_right_screen, prev_stripe_screen[1], prev_stripe_screen[0])
                        draw_points(points, STRIPE_COLOUR, &quot;stripe&quot;)

                    # Draw yellow lines
                    # This is before the drawing of the track as we want to draw on top of the track, and items in the
                    # draw list are drawn in reverse order
                    if SHOW_YELLOW_LINES:
                        left_yellow_line_points = (prev_yellow_line_left_outer_screen,
                                                     yellow_line_left_outer_screen,
                                                     yellow_line_left_inner_screen,
                                                     prev_yellow_line_left_inner_screen)
                        draw_points(left_yellow_line_points, YELLOW_LINE_COL, &quot;yellow line L&quot;)

                        right_yellow_line_points = (prev_yellow_line_right_outer_screen,
                                                     yellow_line_right_outer_screen,
                                                     yellow_line_right_inner_screen,
                                                     prev_yellow_line_right_inner_screen)
                        draw_points(right_yellow_line_points, YELLOW_LINE_COL, &quot;yellow line R&quot;)


                    # Draw track
                    points = (prev_track_screen[0], left_screen, right_screen, prev_track_screen[1])
                    draw_points(points, track_piece.col, &quot;track&quot;)

                    # Draw rumble strip
                    # This is before trackside as it draws on top of trackside, and items in the draw list are drawn
                    # in reverse order
                    if SHOW_RUMBLE_STRIPS:
                        # Alternating colours
                        rumble_col = RUMBLE_COLOUR_1 if (i // 2) % 2 == 0 else RUMBLE_COLOUR_2
                        rumble_left_points = (prev_rumble_left_outer_screen, prev_track_screen[0], left_screen, rumble_strip_left_outer_screen)
                        rumble_right_points = (prev_rumble_right_outer_screen, prev_track_screen[1], right_screen, rumble_strip_right_outer_screen)
                        draw_points(rumble_left_points, rumble_col, &quot;rumble L&quot;)
                        draw_points(rumble_right_points, rumble_col, &quot;rumble R&quot;)

                    # Draw trackside
                    if SHOW_TRACKSIDE:
                        # Alternating colours
                        trackside_col = TRACKSIDE_COLOUR_1 if (i // 5) % 2 == 0 else TRACKSIDE_COLOUR_2
                        trackside_left_points = (points[2], points[3], (0, points[3].y), (0, points[2].y))
                        trackside_right_points = (points[0], points[1], (WIDTH - 1, points[1].y), (WIDTH - 1, points[0].y))
                        draw_points(trackside_left_points, trackside_col, &quot;trackside left&quot;)
                        draw_points(trackside_right_points, trackside_col, &quot;trackside right&quot;)

                # Store screen positions of various parts of the track, as they form half of the polygon for the next
                # track piece
                prev_track_screen = (left_screen, right_screen)
                prev_stripe_screen = (stripe_left_screen, stripe_right_screen)
                prev_rumble_left_outer_screen = rumble_strip_left_outer_screen
                prev_rumble_right_outer_screen = rumble_strip_right_outer_screen
                prev_yellow_line_left_outer_screen = yellow_line_left_outer_screen
                prev_yellow_line_left_inner_screen = yellow_line_left_inner_screen
                prev_yellow_line_right_outer_screen = yellow_line_right_outer_screen
                prev_yellow_line_right_inner_screen = yellow_line_right_inner_screen

                # Show debug info for this track piece
                if SHOW_TRACK_PIECE_INDEX or SHOW_TRACK_PIECE_OFFSETS:
                    items = []
                    if SHOW_TRACK_PIECE_INDEX:
                        items.append(str(i))
                    if SHOW_TRACK_PIECE_OFFSETS:
                        items.extend([str(track_piece.offset_x), str(track_piece.offset_y)])
                    text = &quot;,&quot;.join(items)
                    add_to_draw_list(lambda left_screen=left_screen, text=text:
                                        screen.draw.text(text, (left_screen[0], left_screen[1] - 30)))

            # Draw scenery for the current track piece
            if SHOW_SCENERY:
                for obj in track_piece.scenery:
                    if track_ahead_i * SPACING &lt; obj.max_draw_distance:
                        pos_v3 = Vector3(obj.x, 0, current_piece_z) + offset
                        if self.camera.z - current_piece_z &gt; obj.min_draw_distance:
                            billboard = obj.get_image()
                            pos, scaled_w, scaled_h = transform(pos_v3, billboard.get_width() * obj.scale,
                                                                billboard.get_height() * obj.scale)
                            # If a piece of scenery is very close to the camera, the scaled size may become enormous.
                            # Don&#x27;t try to draw such scenery, due to memory and frame rate issues
                            if pos is not None and scaled_w &lt; MAX_SCENERY_SCALED_WIDTH:
                                # Anchor point at bottom
                                pos -= Vector2(scaled_w // 2, scaled_h)
                                try:
                                    profile_scale = Profiler()
                                    scaled = SCALE_FUNC(billboard, (int(scaled_w), int(scaled_h)))
                                    times[&quot;scenery_scale&quot;] += profile_scale.get_ms()
                                    add_to_draw_list(lambda scaled=scaled, pos=pos: screen.blit(scaled, pos),
                                                     &quot;scenery_draw&quot;)
                                except pygame.error:
                                    # Have experienced out of memory errors with a too-small clipping plane, due to trying to
                                    # scale to too big a size. In extreme cases Pygame may try to allocate bitmaps over 1GB
                                    # in size!
                                    print(f&quot;SCALE ERROR, w/h: {scaled_w} {scaled_h}&quot;)

            # Draw cars
            profile_prepare_draw_cars = Profiler()
            cars_to_draw = []
            for car in track_piece.cars:
                # Each car needs to be drawn during the track piece it is on, but with an additional offset interpolated
                # towards the next track piece, so that it starts turning a corner as it reaches the piece
                # Also, the order of  drawing needs to be correct if there is more than one car per track piece
                car_offset = Vector3(offset)
                if car.pos.z % SPACING != 0:
                    # Interpolate offset between this and next track piece
                    # Note that &quot;Interpolate for X offset between first and next track piece&quot;
                    # will already have happened! Does that matter?

                    # The following lines deal with the car when it&#x27;s moving onto a track piece with an offset
                    fraction = inverse_lerp(current_piece_z, current_piece_z - SPACING, car.pos.z)
                    next_track_piece = self.track[i + 1]
                    car_offset += Vector3(fraction * next_track_piece.offset_x,
                                          fraction * next_track_piece.offset_y, -fraction * SPACING)

                    # This ensures that the car&#x27;s forward motion is correct on pieces following a piece with an offset
                    car_offset += offset_delta * fraction

                # The rules for drawing the player car (or whichever car the camera is following, in demo mode) are
                # a bit different. If we drew it in the same way, its position on the screen would be a bit off as
                # it would start going around corners before the camera does. So don&#x27;t apply any offset.
                # (For Y offset, you can achieve an interesting effect by changing 0 to -car_offset.y / 2, but
                # it is a bit glitchy sometimes so we&#x27;ve left it at zero)
                if car is self.camera_follow_car:
                    car_offset.x = 0
                    car_offset.y = 0

                pos_v3 = Vector3(car.pos.x, 0, current_piece_z) + car_offset
                scale = 2

                # For CPU cars, choose the sprite to use based on the car&#x27;s angle in relation to the camera
                if isinstance(car, CPUCar):
                    # Approximate the angle we&#x27;re seeing the car from, to determine the sprite
                    # The further the car is ahead, the smaller the effect
                    # The car sprite filenames end in a number in the range -4 to 4, where 0 is the car not turning,
                    # -1 is the car turning slightly to the left, 1 is turning slightly to the right, etc
                    z_distance = max(1, -(pos_v3.z - self.camera.z))
                    offset_for_angle = (pos_v3.x - self.camera.x) / z_distance
                    offset_for_angle += -car.steering * 10
                    angle_sprite_idx = int(remap_clamp(offset_for_angle, -200, 200, -4, 4))

                    # If this is the camera follow car (which for a CPU car will only be the case during
                    # the title screen), limit to only the shallowest angles (-1 to 1), as this car is a stand-in
                    # for the plyaer car and the player car only uses angles between -1 and 1
                    if car is self.camera_follow_car:
                        angle_sprite_idx = min(max(angle_sprite_idx, -1), 1)

                    car.update_sprite(angle_sprite_idx, braking=False)

                # Calculate screen pos and scaled sprite size for car
                img = getattr(images, car.image)
                pos, scaled_w, scaled_h = transform(pos_v3,
                                                    img.get_width() * scale,
                                                    img.get_height() * scale,
                                                    clipping_plane=CLIPPING_PLANE_CARS)

                if pos is not None and scaled_w &lt; MAX_CAR_SCALED_WIDTH:
                    # Anchor point at bottom, centre
                    pos -= Vector2(scaled_w // 2, scaled_h)
                    profile_scale = Profiler()
                    scaled = SCALE_FUNC(img, (int(scaled_w), int(scaled_h)))
                    times[&quot;car_scale&quot;] += profile_scale.get_ms()

                    # We can&#x27;t send it to the draw list just yet as there might be more than one car on this track
                    # piece and we need to draw them in order starting from the one furthest from the camera.
                    # So we&#x27;ll add it to a list to sort and draw later
                    cars_to_draw.append({&quot;z&quot;: car.pos.z, &quot;drawcall&quot;: lambda scaled=scaled, pos=pos: screen.blit(scaled, pos)})

                    if SHOW_CPU_CAR_SPEEDS and isinstance(car, CPUCar):
                        output = f&quot;{car.target_speed:.0f}&quot;
                        add_to_draw_list(lambda pos=pos, output=output: draw_text(output, pos.x, pos.y - 40))

            times[&quot;prepare_draw_cars&quot;] += profile_prepare_draw_cars.get_ms()

            # Draw the cars that are on the current track piece,starting from the one with the lowest Z position
            cars_to_draw.sort(key=lambda entry: entry[&quot;z&quot;], reverse=True)
            for entry in cars_to_draw:
                add_to_draw_list(entry[&quot;drawcall&quot;], &quot;cars&quot;)

        # Draw everything in draw_list, in reverse order - so that items furthest ahead are drawn first
        for draw_call, type in reversed(draw_list):
            profiler = Profiler()
            draw_call()
            if type not in times:
                times[type] = profiler.get_ms()
            else:
                times[type] += profiler.get_ms()

        # Is there an actual player car, or are we in demo mode?
        if self.player_car is not None:
            # Show info text
            # Adapt to varying window widths by using fractions of WIDTH instead of absolute coordinates

            player_pos = self.cars.index(self.player_car) + 1

            # Show race complete or time up screens if relevant
            if self.time_up:
                draw_text(&quot;TIME UP!&quot;, WIDTH // 2, HEIGHT * 0.4, centre=True)

            elif self.race_complete:
                draw_text(&quot;RACE COMPLETE!&quot;, WIDTH // 2, HEIGHT * 0.15, centre=True)
                draw_text(&quot;POSITION&quot;, WIDTH // 2, HEIGHT * 0.3, centre=True)
                draw_text(str(player_pos), WIDTH // 2, HEIGHT * 0.42, centre=True)
                draw_text(&quot;FASTEST LAP&quot;, WIDTH * 0.25, HEIGHT * 0.55, centre=True)
                draw_text(format_time(self.player_car.fastest_lap), WIDTH * 0.25, HEIGHT * 0.68, centre=True)
                draw_text(&quot;RACE TIME&quot;, WIDTH * 0.75, HEIGHT * 0.55, centre=True)
                draw_text(format_time(self.player_car.race_time), WIDTH * 0.75, HEIGHT * 0.68, centre=True)

            else:
                # Race not complete - show status text at top of screen

                # Show status background
                status_x = (WIDTH /2) - (565 / 2)
                screen.blit(&quot;status&quot;, (status_x, 0))

                # Show lap
                draw_text(f&quot;{self.player_car.lap:02}&quot;, status_x + 30, 37, font=&quot;status1b_&quot;)

                # Show position
                draw_text(f&quot;{player_pos:02}&quot;, status_x + 116, 37, font=&quot;status1b_&quot;)

                # Show speed
                draw_text(f&quot;{int(self.player_car.speed):03}&quot;, status_x + 197, 37, font=&quot;status1b_&quot;)

                # Show lap time
                draw_text(format_time(self.player_car.lap_time), status_x + 299, 37, font=&quot;status2_&quot;)

                # Show fastest lap
                if self.player_car.last_lap_was_fastest and self.player_car.lap_time &lt; 4:
                    y = HEIGHT * 0.4
                    draw_text(&quot;FASTEST LAP!&quot;, WIDTH // 2, y, centre=True)
                    draw_text(format_time(self.player_car.fastest_lap), WIDTH // 2, y + 60, centre=True)

                # Show final lap text
                # If we&#x27;re currently showing fastest lap text, wait for that to disappear before showing the final
                # lap text
                if self.player_car.last_lap_was_fastest:
                    begin_time, end_time = 4, 8
                else:
                    begin_time, end_time = 0, 4
                if self.player_car.lap == NUM_LAPS and begin_time &lt; self.player_car.lap_time &lt; end_time:
                    y = HEIGHT * 0.4
                    draw_text(&quot;FINAL LAP!&quot;, WIDTH // 2, y, centre=True)

        # Show debug text
        if SHOW_DEBUG_TEXT:
            for i in range(len(self.on_screen_debug_strs)):
                screen.draw.text(self.on_screen_debug_strs[i], (0, 50 + i * 20))
        self.on_screen_debug_strs.clear()

        if SHOW_PROFILE_TIMINGS:
            print(prof_track, sum(times.values()))

            # if sum(times.values()) &gt; 16:
            print(self.frame_counter, times)

            # test drawing a very large polygon
            # pygame.draw.polygon(screen.surface, (255,0,0), (Vector2(-4000,test), Vector2(WIDTH*4,test), Vector2(0,test+500)))

    # Returns index of track piece at the specified Z position, or None if the specified position is off the end
    # of the track
    # e.g. track piece 0 goes from Z 0 to -0.999, etc
    def get_track_piece_for_z(self, z):
        idx = -int(z / SPACING)
        if idx &gt;= len(self.track):
            return None
        else:
            return idx

    # Returns index and Z position of first track piece ahead of or exactly at the specified Z position, or None,None
    # if the specified position is off the end of the track
    def get_first_track_piece_ahead(self, z):
        idx = -int(math.floor(z / SPACING))
        first_piece_z = -idx * SPACING
        if idx &gt;= len(self.track):
            return None, None
        else:
            return idx, first_piece_z

    def play_sound(self, name, count=1):
        # Some sounds have multiple varieties. If count &gt; 1, we&#x27;ll randomly choose one from those
        # We don&#x27;t play any sounds if there is no player (e.g. if we&#x27;re on the menu)
        try:
            # Pygame Zero allows you to write things like &#x27;sounds.explosion.play()&#x27;
            # This automatically loads and plays a file named &#x27;explosion.wav&#x27; (or .ogg) from the sounds folder (if
            # such a file exists)
            # But what if you have files named &#x27;explosion0.ogg&#x27; to &#x27;explosion5.ogg&#x27; and want to randomly choose
            # one of them to play? You can generate a string such as &#x27;explosion3&#x27;, but to use such a string
            # to access an attribute of Pygame Zero&#x27;s sounds object, we must use Python&#x27;s built-in function getattr
            sound = getattr(sounds, name + str(randint(0, count - 1)))
            sound.play()
        except Exception as e:
            # If no sound file of that name was found, print the error that Pygame Zero provides, which
            # includes the filename.
            # Also occurs if sound fails to play for another reason (e.g. if this machine has no sound hardware)
            print(e)

def get_joystick_if_exists():
    return pygame.joystick.Joystick(0) if pygame.joystick.get_count() &gt; 0 else None

def setup_joystick_controls():
    # We call this on startup, and keep calling it if no controller is present,
    # so a controller can be connected while the game is open
    global joystick_controls
    joystick = get_joystick_if_exists()
    joystick_controls = JoystickControls(joystick) if joystick is not None else None

def update_controls():
    keyboard_controls.update()
    # Allow a controller to be connected while the game is open
    if joystick_controls is None:
        setup_joystick_controls()
    if joystick_controls is not None:
        joystick_controls.update()

class State(Enum):
    TITLE = 1
    PLAY = 2
    GAME_OVER = 3


# Pygame Zero calls the update and draw functions each frame

def update(delta_time):
    # delta_time is the time passed (in seconds) since the previous frame
    global state, game, accumulated_time, demo_reset_timer, demo_start_timer

    update_controls()

    def button_pressed_controls(button_num):
        # Local function for detecting button 0 being pressed on either keyboard or controller, returns the controls
        # object which was used to press it, or None if button was not pressed
        for controls in (keyboard_controls, joystick_controls):
            # Check for fire button being pressed on each controls object
            # joystick_controls will be None if there no controller was connected on game startup,
            # so must check for that
            if controls is not None and controls.button_pressed(button_num):
                return controls
        return None

    if state == State.TITLE:
        # Check for player starting game with either keyboard or controller
        controls = button_pressed_controls(0)
        if controls is not None:
            # Switch to play state, and create a new Game object, passing it a controls object
            state = State.PLAY
            game = Game(controls)

        # If the demo race has been running for a while, reset it, otherwise the AI cars will run out of track!
        demo_reset_timer -= delta_time
        demo_start_timer += delta_time
        if demo_reset_timer &lt;= 0:
            game = Game()
            demo_reset_timer = 60 * 2
            demo_start_timer = 0

    elif state == State.PLAY:
        if game.race_complete:
            state = State.GAME_OVER

    elif state == State.GAME_OVER:
        if button_pressed_controls(0) is not None:
            # Go back into demo/title screen mode - create a new Game object without a player
            # First stop the player car&#x27;s skid sound
            game.player_car.stop_engine_sound()

            state = State.TITLE
            game = Game()
            play_music(&quot;title_theme&quot;)

    # Call game.update each time while accumulated_time is above FIXED_TIMESTEP. If it is double or more of FIXED_TIMESTEP,
    # which would occur if the frame rate is low, we call game.update two or more times per frame
    accumulated_time += delta_time
    while accumulated_time &gt;= FIXED_TIMESTEP:
        accumulated_time -= FIXED_TIMESTEP
        game.update(FIXED_TIMESTEP)

def draw():
    game.draw()

    if state == State.TITLE:
        if demo_reset_timer &lt; 1 or demo_start_timer &lt; 1:
            # Fade out screen prior to resetting demo game, and fade in whenever demo (re)starts
            # Draw a black image with gradually increasing/decreasing opacity
            # An alpha value of 255 is fully opaque, 0 is fully transparent
            value = demo_reset_timer if demo_reset_timer &lt; 1 else demo_start_timer
            alpha = min(255, 255-(value*255))
            fade_to_black_image.set_alpha(alpha)
            fade_to_black_image.fill((0,0,0))
            screen.blit(fade_to_black_image, (0, 0))

        # Construct start game text
        # On macOS, encourage the user to use Z instead of left control to accelerate, because
        # Ctrl+arrow is the keyboard shortcut to switch desktop
        text = f&quot;PRESS {SPECIAL_FONT_SYMBOLS[&#x27;xb_a&#x27;]} OR {&#x27;Z&#x27; if &#x27;Darwin&#x27; in platform.version() else &#x27;LEFT CONTROL&#x27;}&quot;

        # Draw start game text
        draw_text(text, WIDTH//2, HEIGHT - 82, True)

        # Draw logo - centred on X axis, centred on top third of the screen on Y axis
        logo_img = images.logo
        screen.blit(logo_img, (WIDTH//2 - logo_img.get_width() // 2, HEIGHT//3 - logo_img.get_height() // 2))

def play_music(name):
    try:
        music.play(name)
    except Exception:
        # If an error occurs (e.g. no sound hardware), ignore it
        pass

def stop_music():
    try:
        music.stop()
    except Exception:
        # If an error occurs (e.g. no sound hardware), ignore it
        pass

##############################################################################

# Set up sound system and start music
try:
    # Restart the Pygame audio mixer which Pygame Zero sets up by default. We find that the default settings
    # cause issues with delayed or non-playing sounds on some devices
    pygame.mixer.quit()
    pygame.mixer.init(44100, -16, 2, 1024)

    play_music(&quot;title_theme&quot;)
except Exception:
    # If an error occurs (e.g. no sound hardware), ignore it
    pass

# Set up controls
keyboard_controls = KeyboardControls()
setup_joystick_controls()

# Set up initial state and Game object
state = State.TITLE
game = Game()

demo_reset_timer = 2 * 60    # Demo race resets after 2 mins
demo_start_timer = 0

accumulated_time = 0

# Tell Pygame Zero to take over
pgzrun.go()
</code></pre>
</main>

<script>
/*
 * Leading Edge - Code the Classics Volume 2
 * Code by Andrew Gillett
 * Graphics by Dan Malone
 * Music and sound effects by Allister Brimble
 * https://github.com/raspberrypipress/Code-the-Classics-Vol2.git
 * https://store.rpipress.cc/products/code-the-classics-volume-ii
 */

/*
 * Return a random number N such that min <= N < max.
 */
function getRandom(min, max) {
  return (Math.random() * (max - min)) + min;
}

/*
 * Return a random integer N such that min <= N < max.
 */
function getRandomInteger(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor((Math.random() * (max - min)) + min);
}

/*
 * A JavaScript 2-Dimensional vector based on pygame.math.Vector2.
 */
class Vecta {
  static TAU = Math.PI * 2;

  /*
   * Return true if the Numbers first and second are equal to places.
   *
   * This is necessary because JavaScript Number is a floating point value and is not exact.
   */
  static isAlmostEqual(first, second, places = 7) {
    if (typeof first !== 'number') {
      return false;
    }
    if (typeof second !== 'number') {
      return false;
    }
    return (first.toFixed(places) === second.toFixed(places));
  }

  constructor() {
    let x, y;
    if (arguments.length === 1) {
      if (typeof arguments[0] === 'number') {
        x = arguments[0];
        y = arguments[0];
      }
      else if (typeof arguments[0] === 'object') {
        if (Array.isArray(arguments[0])) {
          [x=0, y=0] = arguments[0];
        }
        else {
          ({x=0, y=0} = arguments[0]);
        }
      }
      else {
        throw new Error('Not enough arguments.');
      }
    }
    else {
      [x=0, y=0] = arguments;
    }

    this.x = x;
    this.y = y;
  }

  /*
   * Return a new Vecta instance resulting from adding the other vector to this vector.
   */
  add() {
    let v;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta) {
      v = arguments[0];
    }
    else {
      v = new Vecta(...arguments);
    }
    return new Vecta(this.x + v.x, this.y + v.y);
  }

  /*
   * Return a new Vecta instance resulting from subtracting the other vector from this vector.
   */
  subtract() {
    let v;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta) {
      v = arguments[0];
    }
    else {
      v = new Vecta(...arguments);
    }
    return new Vecta(this.x - v.x, this.y - v.y);
  }

  /*
   * Return a new Vecta instance resulting from multiplying this vector by a Number.
   */
  multiply() {
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (typeof arguments[0] === 'number') {
      return new Vecta(this.x * arguments[0], this.y * arguments[0]);
    }
    return this.dot(...arguments);
  }

  /*
   * Return a new Vecta instance resulting from dividing this vector by a Number.
   */
  divide(divisor) {
    if (typeof divisor !== 'number') {
      throw new TypeError('divisor must be a Number.');
    }
    return new Vecta(this.x / divisor, this.y / divisor);
  }

  /*
   * Return true if this vector is equal to the other vector.
   */
  isEqual() {
    let v;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta) {
      v = arguments[0];
    }
    else {
      v = new Vecta(...arguments);
    }
    return (Vecta.isAlmostEqual(this.x, v.x) && Vecta.isAlmostEqual(this.y, v.y));
  }

  /*
   * Return a new Vecta instance resulting from rotating this vector by the given angle in degrees.
   */
  rotate(degrees) {
    return this.rotate_rad(degrees * Math.PI / 180);
  }

  /*
   * Return a new Vecta instance resulting from rotating this vector by the given angle in radians.
   */
  rotate_rad(radians) {
    let v = new Vecta(this.x, this.y);
    v.rotate_ip_rad(radians);
    return v;
  }

  /*
   * Rotate this vector by the given angle in degrees.
   */
  rotate_ip(degrees) {
    this.rotate_ip_rad(degrees * Math.PI / 180);
  }

  /*
   * Rotate this vector by the given angle in radians.
   */
  rotate_ip_rad(radians) {
    // Duplicate the code in modulo() so this class does not depend on the function
    radians = ((radians % Vecta.TAU) + Vecta.TAU) % Vecta.TAU;
    if (Vecta.isAlmostEqual(radians, 0)) {
      return;
    }
    let sin = Math.sin(radians),
        cos = Math.cos(radians),
        newX = (cos * this.x) - (sin * this.y),
        newY = (sin * this.x) + (cos * this.y);
    if (Vecta.isAlmostEqual(radians, Math.PI / 2)) {
      newX = -this.y;
      newY = this.x;
    }
    else if (Vecta.isAlmostEqual(radians, Math.PI)) {
      newX = -this.x;
      newY = -this.y;
    }
    else if (Vecta.isAlmostEqual(radians, 3 * Math.PI / 2)) {
      newX = this.y;
      newY = -this.x;
    }

    this.x = newX;
    this.y = newY;
  }

  /*
   * Return a new Vecta instance with the same direction but length 1.
   */
  normalize() {
    let v = new Vecta(this.x, this.y);
    v.normalize_ip();
    return v;
  }

  /*
   * Scale this vector to have length 1.
   */
  normalize_ip() {
    let length = this.length();
    if (length <= 0) {
      throw new RangeError('Cannot normalize Vector of length 0.');
    }
    this.x /= length;
    this.y /= length;
  }

  /*
   * Return true if this vector has length 1.
   */
  is_normalized() {
    return Vecta.isAlmostEqual(this.length_squared(), 1);
  }

  /*
   * Return the cross product of this vector and the other vector.
   */
  cross() {
    let v;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta) {
      v = arguments[0];
    }
    else {
      v = new Vecta(...arguments);
    }
    return ((this.x * v.y) - (this.y * v.x));
  }

  /*
   * Return the dot product of this vector and the other vector.
   */
  dot() {
    let v;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta) {
      v = arguments[0];
    }
    else {
      v = new Vecta(...arguments);
    }
    return ((this.x * v.x) + (this.y * v.y));
  }

  /*
   * Return the angle to the given vector in degrees.
   */
  angle_to() {
    let v;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta) {
      v = arguments[0];
    }
    else {
      v = new Vecta(...arguments);
    }
    return ((Math.atan2(v.y, v.x) - Math.atan2(this.y, this.x)) * 180 / Math.PI);
  }

  /*
   * Scale this vector to the given length.
   */
  scale_to_length(newLength) {
    let length = this.length(),
        fraction;
    if (length <= 0) {
      throw new RangeError('Cannot scale Vector of length 0.');
    }
    fraction = newLength / length;
    this.x *= fraction;
    this.y *= fraction;
  }

  /*
   * Return the Euclidean length/magnitude of this vector.
   */
  length() {
    return Math.hypot(this.x, this.y);
  }

  /*
   * Return the squared Euclidean length/magnitude of this vector.
   */
  length_squared() {
    return ((this.x * this.x) + (this.y * this.y));
  }

  /*
   * Return a new Vecta instance of this vector reflected of the given normal.
   */
  reflect() {
    let n;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta) {
      n = arguments[0];
    }
    else {
      n = new Vecta(...arguments);
    }

    let v = new Vecta(this.x, this.y);
    v.reflect_ip(n);
    return v;
  }

  /*
   * Reflect this vector of the given normal.
   */
  reflect_ip() {
    let v;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta) {
      v = arguments[0];
    }
    else {
      v = new Vecta(...arguments);
    }

    if (Vecta.isAlmostEqual(v.length_squared(), 0)) {
      throw new RangeError('Normal must not be of length 0.');
    }

    let n = v.normalize(),
        dot_product = this.dot(n);
    this.x -= 2 * n.x * dot_product;
    this.y -= 2 * n.y * dot_product;
  }

  /*
   * Return the Euclidean distance to the given vector.
   */
  distance_to() {
    return Math.sqrt(this.distance_squared_to(...arguments));
  }

  /*
   * Return the squared Euclidean distance to the given vector.
   */
  distance_squared_to() {
    let v;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta) {
      v = arguments[0];
    }
    else {
      v = new Vecta(...arguments);
    }
    return (((v.x - this.x) * (v.x - this.x)) + ((v.y - this.y) * (v.y - this.y)));
  }

  /*
   * Set the coordinates of this vector to the new values.
   */
  update() {
    let v;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta) {
      v = arguments[0];
    }
    else {
      v = new Vecta(...arguments);
    }
    this.x = v.x;
    this.y = v.y;
  }
}
Vecta.prototype.toString = function () {
  return `[${ this.x }, ${ this.y }]`;
}

/*
 * A JavaScript 3-Dimensional vector based on pygame.math.Vector3.
 */
class Vecta3D {
  constructor() {
    let x, y, z;
    if (arguments.length === 1) {
      if (typeof arguments[0] === 'number') {
        x = arguments[0];
        y = arguments[0];
        z = arguments[0];
      }
      else if (typeof arguments[0] === 'object') {
        if (Array.isArray(arguments[0])) {
          [x=0, y=0, z=0] = arguments[0];
        }
        else {
          ({x=0, y=0, z=0} = arguments[0]);
        }
      }
      else {
        throw new Error('Not enough arguments.');
      }
    }
    else {
      [x=0, y=0, z=0] = arguments;
    }

    this.x = x;
    this.y = y;
    this.z = z;
  }

  /*
   * Return a new Vecta3D instance resulting from adding the other vector to this vector.
   */
  add() {
    let v;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta3D) {
      v = arguments[0];
    }
    else {
      v = new Vecta3D(...arguments);
    }
    return new Vecta3D(this.x + v.x, this.y + v.y, this.z + v.z);
  }

  /*
   * Return a new Vecta3D instance resulting from subtracting the other vector from this vector.
   */
  subtract() {
    let v;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta3D) {
      v = arguments[0];
    }
    else {
      v = new Vecta3D(...arguments);
    }
    return new Vecta3D(this.x - v.x, this.y - v.y, this.z - v.z);
  }

  /*
   * Return a new Vecta3D instance resulting from multiplying this vector by a Number.
   */
  multiply() {
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (typeof arguments[0] === 'number') {
      return new Vecta3D(this.x * arguments[0], this.y * arguments[0], this.z * arguments[0]);
    }
    return this.dot(...arguments);
  }

  /*
   * Return a new Vecta3D instance resulting from dividing this vector by a Number.
   */
  divide(divisor) {
    if (typeof divisor !== 'number') {
      throw new TypeError('divisor must be a Number.');
    }
    return new Vecta3D(this.x / divisor, this.y / divisor, this.z / divisor);
  }

  /*
   * Return true if this vector is equal to the other vector.
   */
  isEqual() {
    let v;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta3D) {
      v = arguments[0];
    }
    else {
      v = new Vecta3D(...arguments);
    }
    return (Vecta.isAlmostEqual(this.x, v.x) && Vecta.isAlmostEqual(this.y, v.y) && Vecta.isAlmostEqual(this.z, v.z));
  }

  /*
   * Return a new Vecta3D instance resulting from rotating this vector by the given angle in degrees around axis.
   */
  rotate(degrees, axis) {
    return this.rotate_rad(degrees * Math.PI / 180, axis);
  }

  /*
   * Return a new Vecta3D instance resulting from rotating this vector by the given angle in radians around axis.
   */
  rotate_rad(radians, axis) {
    let v = new Vecta3D(this.x, this.y, this.z);
    v.rotate_ip_rad(radians, axis);
    return v;
  }

  /*
   * Rotate this vector by the given angle in degrees around axis.
   */
  rotate_ip(degrees, axis) {
    this.rotate_ip_rad(degrees * Math.PI / 180, axis);
  }

  /*
   * Rotate this vector by the given angle in radians around axis.
   */
  rotate_ip_rad() {
    if (arguments.length <= 1) {
      throw new Error('Not enough arguments.');
    }
    let args = Array.from(arguments),
        radians = args.shift(),
        axis;
    if (typeof radians !== 'number') {
      throw new TypeError('angle must be a Number.');
    }
    if (args[0] instanceof Vecta3D) {
      axis = args[0];
    }
    else {
      axis = new Vecta3D(...args);
    }

    // Duplicate the code in modulo() so this class does not depend on the function
    radians = ((radians % Vecta.TAU) + Vecta.TAU) % Vecta.TAU;
    if (Vecta.isAlmostEqual(radians, 0)) {
      return;
    }

    // Normalize the axis
    axis = axis.normalize();

    let sin = Math.sin(radians),
        cos = Math.cos(radians),
        cosComplement = 1 - cos,
        newX = ((this.x * (cos + (axis.x * axis.x * cosComplement))) +
                (this.y * ((axis.x * axis.y * cosComplement) - (axis.z * sin))) +
                (this.z * ((axis.x * axis.z * cosComplement) + (axis.y * sin)))),
        newY = ((this.x * ((axis.x * axis.y * cosComplement) + (axis.z * sin))) +
                (this.y * (cos + (axis.y * axis.y * cosComplement))) +
                (this.z * ((axis.y * axis.z * cosComplement) - (axis.x * sin)))),
        newZ = ((this.x * ((axis.x * axis.z * cosComplement) - (axis.y * sin))) +
                (this.y * ((axis.y * axis.z * cosComplement) + (axis.x * sin))) +
                (this.z * (cos + (axis.z * axis.z * cosComplement))));
    if (Vecta.isAlmostEqual(radians, Math.PI / 2)) {
      newX = ((this.x * (axis.x * axis.x)) +
              (this.y * ((axis.x * axis.y) - axis.z)) +
              (this.z * ((axis.x * axis.z) + axis.y)));
      newY = ((this.x * ((axis.x * axis.y) + axis.z)) +
              (this.y * (axis.y * axis.y)) +
              (this.z * ((axis.y * axis.z) - axis.x)));
      newZ = ((this.x * ((axis.x * axis.z) - axis.y)) +
              (this.y * ((axis.y * axis.z) + axis.x)) +
              (this.z * (axis.z * axis.z)));
    }
    else if (Vecta.isAlmostEqual(radians, Math.PI)) {
      newX = ((this.x * (-1 + (axis.x * axis.x * 2))) +
              (this.y * (axis.x * axis.y * 2)) +
              (this.z * (axis.x * axis.z * 2)));
      newY = ((this.x * (axis.x * axis.y * 2)) +
              (this.y * (-1 + (axis.y * axis.y * 2))) +
              (this.z * (axis.y * axis.z * 2)));
      newZ = ((this.x * (axis.x * axis.z * 2)) +
              (this.y * (axis.y * axis.z * 2)) +
              (this.z * (-1 + (axis.z * axis.z * 2))));
    }
    else if (Vecta.isAlmostEqual(radians, 3 * Math.PI / 2)) {
      newX = ((this.x * (axis.x * axis.x)) +
              (this.y * ((axis.x * axis.y) + axis.z)) +
              (this.z * ((axis.x * axis.z) - axis.y)));
      newY = ((this.x * ((axis.x * axis.y) - axis.z)) +
              (this.y * (axis.y * axis.y)) +
              (this.z * ((axis.y * axis.z) + axis.x)));
      newZ = ((this.x * ((axis.x * axis.z) + axis.y)) +
              (this.y * ((axis.y * axis.z) - axis.x)) +
              (this.z * (axis.z * axis.z)));
    }

    this.x = newX;
    this.y = newY;
    this.z = newZ;
  }

  /*
   * Return a new Vecta3D instance with the same direction but length 1.
   */
  normalize() {
    let v = new Vecta3D(this.x, this.y, this.z);
    v.normalize_ip();
    return v;
  }

  /*
   * Scale this vector to have length 1.
   */
  normalize_ip() {
    let length = this.length();
    if (length <= 0) {
      throw new RangeError('Cannot normalize Vector of length 0.');
    }
    this.x /= length;
    this.y /= length;
    this.z /= length;
  }

  /*
   * Return true if this vector has length 1.
   */
  is_normalized() {
    return Vecta.isAlmostEqual(this.length_squared(), 1);
  }

  /*
   * Return the cross product of this vector and the other vector.
   */
  cross() {
    let v;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta3D) {
      v = arguments[0];
    }
    else {
      v = new Vecta3D(...arguments);
    }
    return new Vecta3D((this.y * v.z) - (this.z * v.y), (this.z * v.x) - (this.x * v.z), (this.x * v.y) - (this.y * v.x));
  }

  /*
   * Return the dot product of this vector and the other vector.
   */
  dot() {
    let v;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta3D) {
      v = arguments[0];
    }
    else {
      v = new Vecta3D(...arguments);
    }
    return ((this.x * v.x) + (this.y * v.y) + (this.z * v.z));
  }

  /*
   * Return the angle to the given vector in degrees.
   */
  angle_to() {
    let v, temp;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta3D) {
      v = arguments[0];
    }
    else {
      v = new Vecta3D(...arguments);
    }
    temp = Math.sqrt(this.length_squared() * v.length_squared());
    if (temp <= 0) {
      throw new RangeError('angle to zero vector is undefined.');
    }

    return (Math.acos(((this.x * v.x) + (this.y * v.y) + (this.z * v.z)) / temp) * 180 / Math.PI);
  }

  /*
   * Scale this vector to the given length.
   */
  scale_to_length(newLength) {
    let length = this.length(),
        fraction;
    if (length <= 0) {
      throw new RangeError('Cannot scale Vector of length 0.');
    }
    fraction = newLength / length;
    this.x *= fraction;
    this.y *= fraction;
    this.z *= fraction;
  }

  /*
   * Return the Euclidean length/magnitude of this vector.
   */
  length() {
    return Math.hypot(this.x, this.y, this.z);
  }

  /*
   * Return the squared Euclidean length/magnitude of this vector.
   */
  length_squared() {
    return ((this.x * this.x) + (this.y * this.y) + (this.z * this.z));
  }

  /*
   * Return a new Vecta3D instance of this vector reflected of the given normal.
   */
  reflect() {
    let n;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta3D) {
      n = arguments[0];
    }
    else {
      n = new Vecta3D(...arguments);
    }

    let v = new Vecta3D(this.x, this.y, this.z);
    v.reflect_ip(n);
    return v;
  }

  /*
   * Reflect this vector of the given normal.
   */
  reflect_ip() {
    let v;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta3D) {
      v = arguments[0];
    }
    else {
      v = new Vecta3D(...arguments);
    }

    if (Vecta.isAlmostEqual(v.length_squared(), 0)) {
      throw new RangeError('Normal must not be of length 0.');
    }

    let n = v.normalize(),
        dot_product = this.dot(n);
    this.x -= 2 * n.x * dot_product;
    this.y -= 2 * n.y * dot_product;
    this.z -= 2 * n.z * dot_product;
  }

  /*
   * Return the Euclidean distance to the given vector.
   */
  distance_to() {
    return Math.sqrt(this.distance_squared_to(...arguments));
  }

  /*
   * Return the squared Euclidean distance to the given vector.
   */
  distance_squared_to() {
    let v;
    if (arguments.length <= 0) {
      throw new Error('Not enough arguments.');
    }
    if (arguments[0] instanceof Vecta3D) {
      v = arguments[0];
    }
    else {
      v = new Vecta3D(...arguments);
    }
    return (((v.x - this.x) * (v.x - this.x)) + ((v.y - this.y) * (v.y - this.y)) + ((v.z - this.z) * (v.z - this.z)));
  }
}
Vecta3D.prototype.toString = function () {
  return `[${ this.x }, ${ this.y }, ${ this.z }]`;
}

// For a better frame rate, try width/height of 640x480, or even lower
WIDTH = 960;
HEIGHT = 540;

TITLE = "Leading Edge";

// Set to True improve frame rate by turning off scenery, drawing unfilled polygons and changing the draw distance
const PERFORMANCE_MODE = false;

const SHOW_SCENERY = !PERFORMANCE_MODE;
const SHOW_TRACKSIDE = !PERFORMANCE_MODE;
const SHOW_RUMBLE_STRIPS = !PERFORMANCE_MODE;
const SHOW_YELLOW_LINES = !PERFORMANCE_MODE;
const OUTLINE_W = PERFORMANCE_MODE ? 1 : 0;                   // Change to 1 for unfilled polygons, which are a bit faster to draw
const VIEW_DISTANCE = PERFORMANCE_MODE ? 150 : 200;           // This is in units of number of track pieces, try 60 for a better frame rate, try 2000 for a bad frame rate but impressive draw distance

const CLIPPING_PLANE = -0.25;          // too close to 0 = frame rate issues (drawing huge polygons which are mostly off-screen), too far = stuff just in front of camera not being drawn
const CLIPPING_PLANE_CARS = -0.08;     // bring closer to zero to fix occasional flickering of CPU cars when very close to the camera, at the potential cost of frame rate
const MAX_SCENERY_SCALED_WIDTH = WIDTH * 2;    // When scaling scenery based on distance from camera, don't try to draw anything that would be scaled to wider than this
const MAX_CAR_SCALED_WIDTH = WIDTH * 1;        // As above but for cars

// Constants for track
const SPACING = 1;
const TRACK_W = 3000;
const HALF_STRIPE_W = 25;
const HALF_RUMBLE_STRIP_W = 250;
const HALF_YELLOW_LINE_W = 80;
const YELLOW_LINE_DISTANCE_FROM_EDGE = 150;
const TRACK_COLOUR = [35, 96, 198];
const TRACKSIDE_COLOUR_1 = [0, 77, 180];
const TRACKSIDE_COLOUR_2 = [50, 77, 170];
const STRIPE_COLOUR = [70, 192, 255];
const YELLOW_LINE_COL = [0, 161, 88];    // Yes, it's actually green, not yellow. It looks yellow because it's night.
const RUMBLE_COLOUR_1 = [0, 116, 255];
const RUMBLE_COLOUR_2 = [0, 58, 135];
const SECTION_VERY_SHORT = 25;
const SECTION_SHORT = 50;
const SECTION_MEDIUM = 100;
const SECTION_LONG = 200;
const LAMP_X = Math.floor(TRACK_W / 2) + 300;
const BILLBOARD_X = Math.floor(TRACK_W / 2) + 600;

const CAMERA_FOLLOW_DISTANCE = 2;

// Player car gameplay settings
const LOSE_GRIP_SPEED = 50;
const ZERO_GRIP_SPEED = 100;
const PLAYER_ACCELERATION_MAX = 20;
const PLAYER_ACCELERATION_MIN = 10;
const HIGH_ACCEL_THRESHOLD = 30;
const CORNER_OFFSET_MULTIPLIER = 5.8;      // Higher = harder to corner
const STEERING_STRENGTH = 72;              // Higher = steering has a stronger effect

// Min/max CPU car target speeds - see also track generation, some track pieces have target speed overrides set
const CPU_CAR_MIN_TARGET_SPEED = 40;
const CPU_CAR_MAX_TARGET_SPEED = 65;

const NUM_LAPS = 5;
const NUM_CARS = 20;

const GRID_CAR_SPACING = 0.55;     // How spaced out the cars are on the starting grid

// Half-width and height used during point transform, to save having to calculate them each time
const HALF_WIDTH = Math.floor(WIDTH / 2);
const HALF_HEIGHT = Math.floor(HEIGHT / 2);

// Skid sound starts fading in when grip goes below this level
const SKID_SOUND_START_GRIP = 0.8;

// Debug options
const SHOW_TRACK_PIECE_INDEX = false;
const SHOW_TRACK_PIECE_OFFSETS = false;
const SHOW_CPU_CAR_SPEEDS = false;
const SHOW_DEBUG_TEXT = false;
const SHOW_PROFILE_TIMINGS = false;

const FIXED_TIMESTEP = 1 / 60;

// These symbols substitute for the controller button images when displaying text.
// The symbols representing these images must be ones that aren't actually used themselves, e.g. we don't use the
// percent sign in text
const SPECIAL_FONT_SYMBOLS = '%';

// Create a version of SPECIAL_FONT_SYMBOLS where the keys and values are swapped
const SPECIAL_FONT_SYMBOLS_INVERSE = 'xb_a';


// Utility functions

function remap(old_val, old_min, old_max, new_min, new_max) {
  // todo explain
  return ((((new_max - new_min) * (old_val - old_min)) / (old_max - old_min)) + new_min);
}

function remap_clamp(old_val, old_min, old_max, new_min, new_max) {
  // todo explain
  // These first two lines are in case new_min and new_max are inverted
  let lower_limit = Math.min(new_min, new_max),
      upper_limit = Math.max(new_min, new_max);
  return Math.min(upper_limit, Math.max(lower_limit, remap(old_val, old_min, old_max, new_min, new_max)));
}

function inverse_lerp(a, b, value) {
  // todo explain
  if (a !== b) {
    return Math.min(1, Math.max(0, ((value - a) / (b - a))));
  }
  return 0;
}

function sign(x) {
  // Returns 1, 0 or -1 depending on whether number is positive, zero or negative
  if (x === 0) {
    return 0;
  }
  else {
    return (x < 0) ? -1 : 1;
  }
}

function move_towards(n, target, speed) {
  if (n < target) {
    return Math.min(n + speed, target);
  }
  else {
    return Math.max(n - speed, target);
  }
}

function format_time(seconds) {
  // Return time string in the form "minutes:seconds.milliseconds"
  // 06.3f ensures that we always show 2 digits for the whole part of the seconds
  // 6 refers to the total number of characters including the decimal point
  // We want to display times like "1:05.123" not "1:5.123"
  return `${ Math.trunc(Math.floor(seconds / 60)) }:${ (seconds % 60).toFixed(3).padStart(6, '0') }`;
}

function get_char_image_and_width(char, font) {
  // Return width of given character. ord() gives the ASCII/Unicode code for the given character.
  if (char === " ") {
    return [null, 30];
  }
  else {
    let name;
    if (char === SPECIAL_FONT_SYMBOLS) {
      name = SPECIAL_FONT_SYMBOLS_INVERSE;
    }
    else {
      name = font + "0" + char.charCodeAt(0);
    }
    return [name, images[name].width];
  }
}

const TEXT_GAP_X = new Map([
  ["font", -6],
  ["status1b_", 0],
  ["status2_", 0]]); // Characters in main font are italic so should overlap a little

function text_width(text, font) {
  let total = 0;
  for (let c of text) {
    total += get_char_image_and_width(c, font)[1];
  }
  total += TEXT_GAP_X.get(font) * (text.length - 1);
  return total;
}

function draw_text(text, x, y, centre = false, font = "font") {
  if (centre) {
    x -= Math.floor(text_width(text, font) / 2);
  }

  for (let char of text) {
    let [name, width] = get_char_image_and_width(char, font);
    if (name != null) {
      screen.blit(name, [x, y]);
    }
    x += width + TEXT_GAP_X.get(font);
  }
}

class Controls {
  static NUM_BUTTONS = 2;

  constructor() {
    this.button_previously_down = (new Array(Controls.NUM_BUTTONS)).fill(false);
    this.is_button_pressed = (new Array(Controls.NUM_BUTTONS)).fill(false);
  }

  update() {
    // Call each frame to update button status
    for (let button = 0; button < Controls.NUM_BUTTONS; button++) {
      let button_down = this.button_down(button);
      this.is_button_pressed[button] = button_down && (!this.button_previously_down[button]);
      this.button_previously_down[button] = button_down;
    }
  }

  get_x() {
    // Overridden by subclasses
  }

  button_down(button) {
    // Overridden by subclasses
  }

  button_pressed(button) {
    return this.is_button_pressed[button];
  }
}

class KeyboardControls extends Controls {
  get_x() {
    if (keyboard[keys.LEFT]) {
      return -1;
    }
    else if (keyboard[keys.RIGHT]) {
      return 1;
    }
    else {
      return 0;
    }
  }

  button_down(button) {
    if (button === 0) {
      return keyboard[keys.LCTRL] || keyboard[keys.Z];
    }
    else if (button === 1) {
      return keyboard[keys.LSHIFT] || keyboard[keys.X];
    }
  }
}

class JoystickControls extends Controls {
  constructor(joystick) {
    super();
    this.joystick = joystick;
  }

  get_axis(axis_num) {
    let axis_value = this.joystick.get_axis(axis_num);
    if (Math.abs(axis_value) < 0.6) {
      // Dead-zone
      return 0;
    }
    else {
      return axis_value;
    }
  }

  get_x() {
    return this.get_axis(0);
  }

  /*
   * Note: Copy and paste error in the original Python code.
   */
  get_y() {
    return this.get_axis(1);
  }

  button_down(button) {
    // Before checking button, check to make sure that the controller actually has enough buttons
    // There are some weird devices out there which could cause a crash if this check were not present
    if (this.joystick.get_numbuttons() <= button) {
      console.log("Warning: main controller does not have enough buttons!");
      return false;
    }
    return this.joystick.get_button(button);
  }
}

class Scenery {
  constructor(x, image, min_draw_distance = 0, max_draw_distance = Math.floor(VIEW_DISTANCE / 2), scale = 1, collision_zones = null) {
    this.x = x;
    this.image = image;
    this.min_draw_distance = min_draw_distance;
    this.max_draw_distance = max_draw_distance;
    this.scale = scale;
    if (collision_zones == null) {
      this.collision_zones = [];
    }
    else {
      this.collision_zones = collision_zones;
    }
  }

  get_image() {
    return this.image;
  }
}

class StartGantry extends Scenery {
  constructor() {
    super(0, 'start0', 1, VIEW_DISTANCE, 4, [[-3000, -2400], [2400, 3000]]);
  }

  get_image() {
    // Before we draw, update our billboard image to the appropriate one based on the game's start timer
    // Images go from start0 to start4, then we alternate between start4 and start5 every half second
    let index;
    if (game.start_timer > 0) {
      index = Math.trunc(remap(game.start_timer, 4, 0, 0, 4));
    }
    else {
      index = ((Math.trunc(game.timer * 2) % 2) === 0) ? 4 : 5;
    }
    return "start" + index;
  }
}

class Billboard extends Scenery {
  constructor(x, image) {
    let half_width = images[image].width / 2,
        scale = 2;
    super(x, image, 0, Math.floor(VIEW_DISTANCE / 2), scale, [[-half_width * scale, half_width * scale]]);
  }
}

class LampLeft extends Scenery {
  constructor() {
    super(LAMP_X, 'left_light', 0, Math.floor(VIEW_DISTANCE / 2), 2, [[350, 1200]]);
  }
}

class LampRight extends Scenery {
  constructor() {
    super(-LAMP_X, 'right_light', 0, Math.floor(VIEW_DISTANCE / 2), 2, [[-1200, -350]]);
  }
}

/*
 * The track is defined as list of track pieces. A track piece is technically just a line, but a polygon will be
 * drawn to connect it to the next piece. So being 'on' a track piece means being in between that track piece and the
 * next one. Each track piece has X and Y offsets, which define how its position differs from the previous piece.
 * When the track is drawn, the changes in offset accumulate, so that a series of track pieces with X offsets of 10
 * will lead to a curve to the left, from the camera's point of view. (Left rather than right because the camera
 * points along the negative Z axis)
 * The X and Y offsets are the offsets from the previous track piece, so if, for example, track pieces 0 to 5 have an
 * X offset of zero and track piece 6 has a very large offset of 1000, it's while moving from 5 to 6 that the car
 * will start to move to the left
 */
class TrackPiece {
  constructor(scenery = null, offset_x = 0, offset_y = 0, cpu_max_target_speed = null, col = TRACK_COLOUR, width = TRACK_W) {
    if (scenery == null) {
      this.scenery = [];
    }
    else {
      this.scenery = scenery;
    }
    this.offset_x = offset_x;
    this.offset_y = offset_y;
    this.cpu_max_target_speed = cpu_max_target_speed;
    this.col = col;
    this.width = width;
    this.cars = [];  // Cars currently on this track piece
  }
}

class TrackPieceStartLine extends TrackPiece {
  constructor() {
    super([new StartGantry()], 0, 0, null, [255, 255, 255]);
  }
}

class Car {
  constructor(pos, car_letter) {
    this.pos = pos;
    this.image = `car_${ car_letter }_0_0`;
    this.speed = 0;
    this.grip = 1;
    this.car_letter = car_letter;
    this.track_piece = null;
    this.tyre_rotation = 0;
  }

  update(delta_time) {
    this.pos.z -= this.speed * delta_time;
    this.update_current_track_piece();
    this.tyre_rotation += delta_time * this.speed * 0.75;
  }

  update_current_track_piece() {
    // Which track piece are we on?
    let current_track_piece = this.track_piece,
        idx = game.get_track_piece_for_z(this.pos.z);
    if (idx != null) {
      this.track_piece = game.track[idx];
      if (this.track_piece != current_track_piece) {
        // Remove myself from the old track piece, add myself to the new one
        if (current_track_piece != null) {
          current_track_piece.cars = current_track_piece.cars.filter((car) => (car != this));
        }
        this.track_piece.cars.push(this);
      }
    }
  }

  update_sprite(angle, braking, boost = false) {
    let frame = Math.trunc(this.tyre_rotation % 2) + 1;
    if (this.speed === 0) {
      frame = 0;
    }
    else if (braking) {
      frame = 3;
    }
    else if (boost) {
      frame = Math.trunc(this.tyre_rotation % 2) + 4;
    }
    else {
      frame = Math.trunc(this.tyre_rotation % 2) + 1;
    }
    this.image = `car_${ this.car_letter }_${ (angle < 0) ? 'n' + Math.abs(angle) : angle }_${ frame }`;
  }
}

class CPUCar extends Car {
  constructor(pos, accel, speed) {
    super(pos, ['b', 'c', 'd', 'e'][getRandomInteger(0, 4)]);

    // CPU cars accelerate faster than player but have a lower top speed
    this.accel = PLAYER_ACCELERATION_MAX * accel;
    this.target_speed = speed;
    this.target_x = pos.x;

    // Set based on track curvature, so we can display an angled variant of the car sprite
    this.steering = 0;

    this.change_speed_timer = getRandom(2, 4);
  }

  update(delta_time) {
    if (game.race_complete) {
      this.target_speed = game.player_car.speed;
    }

    this.speed = move_towards(this.speed, this.target_speed, this.accel * delta_time);
    this.pos.x = move_towards(this.pos.x, this.target_x, 400 * delta_time);

    super.update(delta_time);

    let track_piece_idx = game.get_first_track_piece_ahead(this.pos.z)[0];
    if (track_piece_idx != null) {
      this.steering = game.track[track_piece_idx].offset_x;
    }

    // Every few seconds we'll change target speed by a random amount, but upwards on average, so that slow cars
    // have a chance to catch up, and so that we can see CPU cars overtaking each other
    this.change_speed_timer -= delta_time;
    if ((this.change_speed_timer <= 0) && (!game.race_complete)) {
      this.target_speed += getRandom(-4, 6);
      this.target_speed = Math.min(Math.max(this.target_speed, CPU_CAR_MIN_TARGET_SPEED), CPU_CAR_MAX_TARGET_SPEED);

      // If we're on a sharp corner and speed is above a certain level, reduce target speed
      if (track_piece_idx != null) {
        let target_speed_override = game.track[track_piece_idx].cpu_max_target_speed;
        if ((target_speed_override != null) && (this.target_speed > target_speed_override)) {
          // Make it slightly random
          this.target_speed = getRandom(target_speed_override - 3, target_speed_override);
        }
      }

      // Also change target X pos to a random value
      // Ensure not too close to values for nearby cars, to avoid cars driving through each other

      let self = this;
      function is_target_x_too_close_to_nearby_cars() {
        for (let car of game.cars) {
          if ((car != self) && (Math.abs(self.pos.z - car.pos.z) < 20) && (Math.abs(self.target_x - car.pos.x) < 300)) {
            return true;
          }
        }
        return false;
      }

      // Limit number of attempts to ensure no chance of infinite loop
      for (let attempt = 0; attempt < 20; attempt++) {
        this.target_x = getRandom(-1000, 1000);
        if (!is_target_x_too_close_to_nearby_cars()) {
          break;
        }
      }

      // Reset timer
      this.change_speed_timer = getRandom(2, 4);
    }
  }
}

class PlayerCar extends Car {
  constructor(pos, controls) {
    super(pos, 'a');
    this.pos = pos;
    this.controls = controls;
    this.offset_x_change = 0;
    this.resetting = false;
    this.explode_timer = null;
    this.last_checkpoint_idx = null;
    this.lap = 1;
    this.lap_time = 0;
    this.race_time = 0;
    this.fastest_lap = null;
    this.last_lap_was_fastest = false;
    this.braking = false;

    // Load engine and skid sounds. These are not played with Game.play_sound as they require custom behaviour.
    // Enclosed in a try/except section to deal with the case where the sound files can't be loaded, which can
    // occur if there is no sound hardware or sound is disabled
    this.engine_sounds = [];
    for (let i = 0; i < 40; i++) {
      this.engine_sounds.push("engine_short" + i);
    }
    this.skid_sound = sounds.skid_loop0;

    this.current_engine_sound = null;
    this.current_engine_sound_idx = -1;
    this.update_engine_sound();

    this.skid_sound_playing = false;

    this.grass_sound_repeat_timer = 0;
    this.on_grass = false;

    // Last known position in the race, indexed from 0 - used to decide when to play overtaking sounds
    this.prev_position = NUM_CARS - 1;
  }

  stop_engine_sound() {
    if (this.current_engine_sound != null) {
      this.current_engine_sound.stop();
    }
  }

  update(delta_time) {
    if (!game.race_complete) {
      this.lap_time += delta_time;
      this.race_time += delta_time;
    }

    this.grass_sound_repeat_timer -= delta_time;

    this.update_engine_sound();

    // Play overtaking sounds? See if our position in the race has changed since last frame
    let current_position = game.cars.indexOf(this);
    if (current_position !== this.prev_position) {
      // Only play sound if speed difference is high enough
      if (Math.abs(this.speed - game.cars[this.prev_position].speed) > 4) {
        game.play_sound("overtake", 6);
      }

      this.prev_position = current_position;
    }

    if (this.resetting) {
      if (this.explode_timer != null) {
        this.explode_timer += 1;
        if (this.explode_timer > 31) {
          this.explode_timer = null;
        }
      }
      else {
        // Reset player to centre of track over about 2 seconds
        this.pos.x = move_towards(this.pos.x, 0, 2000 * delta_time);
        this.resetting = this.pos.x !== 0;
      }
    }

    let x_move = 0,
        accel = 0,
        drag_factor = 0.9975,
        previous_track_piece_idx, track_piece_idx, track_piece, volume;

    if (!this.resetting) {
      // Not resetting - do normal movement & controls

      this.braking = false;

      // Only get control inputs if race is not complete
      if (!game.race_complete) {
        this.controls.update();
        if (this.controls.button_down(0)) {
          accel = (this.speed < HIGH_ACCEL_THRESHOLD) ? PLAYER_ACCELERATION_MAX : PLAYER_ACCELERATION_MIN;
          this.speed += accel * delta_time;
        }
        else if (this.controls.button_down(1)) {
          // Brake
          this.braking = true;
          this.speed = Math.max(0, this.speed - (delta_time * 10));
        }
      }

      // Apply drag in a frame-rate independent way
      if (this.on_grass) {
        // More drag on grass
        drag_factor -= 0.0025;
      }

      // Apply drag to speed. ** = power, e.g. 3 ** 5 is 3 to the power of 5
      // Check out this superb video which explains the uses and misuses of delta times, including more advanced
      // uses as seen in this case: https://www.youtube.com/watch?v=yGhfUcPjXuE
      this.speed *= drag_factor ** (delta_time / (1 / 60));

      // If we're going round a corner, shift X pos so that failing to steer will take you off the track
      // This is necessary because in this game, the corners are just illusions!
      if (this.offset_x_change !== 0) {
        // We also set self.grip to less than 1 if we're cornering at high speed (but only if we're steering
        // in same direction as corner)
        if ((this.speed > LOSE_GRIP_SPEED) && (sign(this.get_x_input()) === -sign(this.offset_x_change))) {
          this.grip = remap_clamp(this.speed, LOSE_GRIP_SPEED, ZERO_GRIP_SPEED, 1, 0);
        }
        else {
          this.grip = 1;
        }

        // Apply corner offset - grip will be used to alter steering movement in Car.update
        // We don't multiply by delta_time here as offset_x_change is partly based on the total amount of forward
        // motion that has taken place since the previous frame, which already takes delta_time into account
        // We don't do this if the race is complete - just let car go around the corners with no steering needed
        if (!game.race_complete) {
          this.pos.x -= this.offset_x_change * CORNER_OFFSET_MULTIPLIER;
        }
      }

      else {
        // Not going around a corner
        this.grip = 1;
      }

      // Get track piece we were on before forward motion was applied
      previous_track_piece_idx = game.get_first_track_piece_ahead(this.pos.z)[0];

      // Apply steering
      if ((this.speed > 0) && (!game.race_complete)) {
        x_move = this.get_x_input() * this.speed * STEERING_STRENGTH * this.grip * delta_time;
        this.pos.x -= x_move;
      }

      // Call parent (Car) update method, which includes applying motion
      super.update(delta_time);

      // Check for collisions with other cars
      const COLLIDE_FRONT_DISTANCE_Z = 0.6;
      const COLLIDE_BACK_DISTANCE_Z = 1.2;
      for (let car of game.cars) {
        if (car != this) {
          // Note - axes are not uniform in scale (1 unit in X axis is much smaller than 1 unit in Z axis),
          // so we can't do a normal distance calculation.
          // Instead we just check X and Z differences separately (Y is irrelevant as cars are always
          // on the ground)
          let vec = this.pos.subtract(car.pos),
              midpoint;
          if ((Math.abs(vec.x) < 260) && (vec.z < COLLIDE_FRONT_DISTANCE_Z) && (vec.z > -COLLIDE_BACK_DISTANCE_Z)) {
            midpoint = ((this.pos.z - car.pos.z) / 2) + car.pos.z;
            // Which side did we collide on?
            // An alternative way to do this would be to use the speed difference, e.g. if player speed
            // is faster, we hit the car in front
            if (Math.abs(vec.z) < 0.2) {
              // Side collision
              this.pos.x += sign(vec.x) * 50;
              car.pos.x -= sign(vec.x) * 50;
            }

            else if (vec.z > 0) {
              // Colliding with the back of the car in front
              this.speed = Math.max(car.speed - 3, 0);
              car.speed = Math.max(car.speed, this.speed + 3);
              car.target_speed = car.speed;

              // Shift us back and other car forward so we're not longer overlapping
              this.pos.z = midpoint + (COLLIDE_FRONT_DISTANCE_Z * 0.6);
              car.pos.z = midpoint - (COLLIDE_FRONT_DISTANCE_Z * 0.6);

              game.play_sound("bump", 6);
            }

            else {
              // Car behind collided with us - get a speed boost
              this.speed = Math.max(this.speed, car.speed + 3);
              car.speed = Math.max(this.speed - 3, 0);

              // Shift other car back and us forward so we're not longer overlapping
              this.pos.z = midpoint - (COLLIDE_BACK_DISTANCE_Z * 0.6);
              car.pos.z = midpoint + (COLLIDE_BACK_DISTANCE_Z * 0.6);

              game.play_sound("bump_behind");
            }
          }
        }
      }

      // Check for collisions with scenery, driving on grass and passing a checkpoint
      track_piece_idx = game.get_first_track_piece_ahead(this.pos.z)[0];
      if (track_piece_idx != null) {
        track_piece = game.track[track_piece_idx];

        for (let scenery of track_piece.scenery) {
          for (let collision_zone of scenery.collision_zones) {
            let zone_left = scenery.x + collision_zone[0],
                zone_right = scenery.x + collision_zone[1];
            if ((zone_left < this.pos.x) && (this.pos.x < zone_right)) {
              this.speed = 0;
              this.resetting = true;
              this.explode_timer = 0;  // Start explosion animation
              game.play_sound("explosion");
            }
          }
        }

        // Are we on, or have we passed, a checkpoint?
        for (let i = previous_track_piece_idx; i < (track_piece_idx + 1); i++) {
          if (game.track[i] instanceof TrackPieceStartLine) {
            // It's a checkpoint. If it's the first one, ignore it (passing the start line at the start of
            // the race is not of interest). If we've already dealt with this checkpoint, ignore it.
            // Otherwise update lap count and lap time
            if ((this.last_checkpoint_idx != null) && (this.last_checkpoint_idx !== i)) {
              this.lap += 1;

              // Was this the fastest lap?
              if ((this.fastest_lap == null) || (this.lap_time < this.fastest_lap)) {
                this.fastest_lap = this.lap_time;
                this.last_lap_was_fastest = true;
                game.play_sound("fastlap");
              }
              else {
                this.last_lap_was_fastest = false;
              }

              // Play final lap sound effect?
              if (this.lap === NUM_LAPS) {
                game.play_sound("final_lap");
              }

              // Set lap time back to 0 for new lap
              this.lap_time = 0;
            }

            this.last_checkpoint_idx = i;
          }
        }

        // Are we on the grass?
        if ((Math.abs(this.pos.x) + 100) > (track_piece.width / 2)) {
          this.on_grass = true;
          if (this.grass_sound_repeat_timer <= 0) {
            game.play_sound("hit_grass");
            this.grass_sound_repeat_timer = 0.15;
          }

          // Are we way too far off the track? Reset if so
          if (Math.abs(this.pos.x) > 6000) {
            this.speed = 0;
            this.resetting = true;
          }
        }
        else {
          this.on_grass = false;
        }
      }

      // End of "if not self.resetting" block
    }

    // Depending on grip, turn skid sound on/off or vary volume
    if (this.skid_sound != null) {
      // Determine volume to play skid sound at
      if (this.resetting || (this.grip >= SKID_SOUND_START_GRIP) || (this.get_x_input() === 0)) {
        volume = 0;
      }

      else {
        volume = remap_clamp(this.grip, SKID_SOUND_START_GRIP, 0.5, 0, 1);

        // Scale volume based on track curvature - higher volume for tighter corners
        if (track_piece_idx != null) {
          track_piece = game.track[track_piece_idx];
          volume *= remap_clamp(Math.abs(track_piece.offset_x), 0, 15, 0, 1);
        }
      }

      if (volume > 0) {
        if (!this.skid_sound_playing) {
          this.skid_sound.play(-1, 0.100);  // Loop indefinitely
          this.skid_sound_playing = true;
        }

        this.skid_sound.set_volume(volume);
      }
      else {
        this.skid_sound_playing = false;
        this.skid_sound.fadeout(0.250);
      }
    }

    // Set sprite
    if (this.explode_timer != null) {
      this.image = `explode${ Math.floor(this.explode_timer / 2).toFixed().padStart(2, '0') }`;
    }
    else {
      let direction = 0,
          boost = (accel > 0) && (this.speed < HIGH_ACCEL_THRESHOLD) && (this.speed > 0);
      if (x_move < 0) {
        direction = -1;
      }
      else if (x_move > 0) {
        direction = 1;
      }
      this.update_sprite(direction, this.braking, boost);
    }
  }

  update_engine_sound() {
    let sound_index = Math.min(Math.trunc(this.speed * 0.6), this.engine_sounds.length - 1),
        old_sound;
    if (sound_index !== this.current_engine_sound_idx) {
      this.current_engine_sound_idx = sound_index;
      old_sound = this.current_engine_sound;
      this.current_engine_sound = sounds[this.engine_sounds[sound_index]];
      this.current_engine_sound.set_volume(0.3);

      // Stop the old sound and play the new sound - ignore errors (e.g. no sound hardware)
      if (old_sound != null) {
        old_sound.fadeout(0.150);
      }
      this.current_engine_sound.play(-1, 0.100);
    }
  }

  get_x_input() {
    return this.controls.get_x();
  }

  set_offset_x_change(value) {
    this.offset_x_change = value;
  }
}


function generate_scenery(track_i, image = 'billboard00', interval = 40, lamps = true) {
  if ((track_i % interval) === 0) {
    // Billboards
    return [new Billboard(BILLBOARD_X, image), new Billboard(-BILLBOARD_X, image)];
  }
  else if (lamps && ((track_i % 30) === 0)) {
    // Lamps
    return [new LampLeft(), new LampRight()];
  }
  else {
    return [];
  }
}

function make_track() {
  // Each track piece in the list represents a line with a particular width, with optional attached scenery.
  // When the track is drawn, we draw a polygon for each track piece, connecting this line with the line of the
  // previous track piece.
  let track = [];
  for (let lap = 0; lap < (NUM_LAPS + 1); lap++) {
    for (let i = 0; i < 15; i++) {
      track.push(new TrackPiece(generate_scenery(i, 'billboard02')));
    }

    // Start gantry
    track.push(new TrackPieceStartLine());

    for (let i = 0; i < SECTION_SHORT; i++) {
      track.push(new TrackPiece());
    }

    // Because the camera is pointing down the negative Z axis, negative/positive X mean right/left from
    // camera's perspective

    // Mild right turn followed by short straight
    for (let i = 0; i < SECTION_MEDIUM; i++) {
      track.push(new TrackPiece(generate_scenery(i), -4, 0));
    }
    for (let i = 0; i < SECTION_SHORT; i++) {
      track.push(new TrackPiece(generate_scenery(i, 'billboard01')));
    }

    // Slight downward slope, going into moderate right hand turn
    for (let i = 0; i < SECTION_VERY_SHORT; i++) {
      track.push(new TrackPiece(generate_scenery(i), 0, -1));
    }
    for (let i = 0; i < SECTION_VERY_SHORT; i++) {
      track.push(new TrackPiece(generate_scenery(i), 0, -2));
    }
    for (let i = 0; i < SECTION_VERY_SHORT; i++) {
      track.push(new TrackPiece(generate_scenery(i), -2, -1));
    }
    for (let i = 0; i < SECTION_VERY_SHORT; i++) {
      track.push(new TrackPiece(generate_scenery(i, 'billboard03'), -5, 0));
    }
    for (let i = 0; i < SECTION_MEDIUM; i++) {
      track.push(new TrackPiece(generate_scenery(i, 'billboard03'), -10, 0));
    }

    // Short straight
    for (let i = 0; i < SECTION_SHORT; i++) {
      track.push(new TrackPiece(generate_scenery(i)));
    }

    // Medium-sharp turn left, slight upward slope
    for (let i = 0; i < SECTION_MEDIUM; i++) {
      track.push(new TrackPiece(generate_scenery(i, 'arrow_left', 10), 13, 1));
    }

    for (let i = 0; i < SECTION_MEDIUM; i++) {
      track.push(new TrackPiece(generate_scenery(i, 'billboard02'), 0, 0));
    }

    // Small hill
    for (let i = 0; i < SECTION_MEDIUM; i++) {
      track.push(new TrackPiece(generate_scenery(i, 'billboard02'), 0, 2));
    }

    // Slightly down and to the right
    for (let i = 0; i < SECTION_LONG; i++) {
      track.push(new TrackPiece(generate_scenery(i, 'billboard01'), -3, -1));
    }

    // Crazy downward curve
    for (let i = 0; i < SECTION_MEDIUM; i++) {
      track.push(new TrackPiece(generate_scenery(i), 0, -4));
    }

    // Upward slope
    for (let i = 0; i < SECTION_LONG; i++) {
      track.push(new TrackPiece(generate_scenery(i, 'billboard03'), 0, 2));
    }

    // Turn to left and up, gradually increasing curve
    for (let j = 1; j < 10; j++) {
      for (let i = 0; i < SECTION_VERY_SHORT; i++) {
        track.push(new TrackPiece(generate_scenery(i), j, j));
      }
    }

    // Downward curve, increasing then decreasing in intensity
    for (let j = 1; j < 10; j++) {
      for (let i = 0; i < SECTION_VERY_SHORT; i++) {
        track.push(new TrackPiece(generate_scenery(i), 0, -j));
      }
    }

    // straight with chevron billboards at end, CPU cars will slow down in this section
    for (let i = 0; i < SECTION_MEDIUM; i++) {
      track.push(new TrackPiece([], 0, 0, 60));
    }
    for (let i = 0; i < SECTION_SHORT; i++) {
      track.push(new TrackPiece(generate_scenery(i, 'arrow_right', 10, false), 0, 0, 58));
    }
    for (let i = 0; i < SECTION_SHORT; i++) {
      track.push(new TrackPiece(generate_scenery(i, 'arrow_right', 10, false), 0, 0, 58));
    }

    // sharp turn right, easing off slightly at end
    for (let i = 0; i < SECTION_SHORT; i++) {
      track.push(new TrackPiece(generate_scenery(i, 'arrow_right', 10, false), -15, 0, 55));
    }
    for (let i = 0; i < SECTION_SHORT; i++) {
      track.push(new TrackPiece(generate_scenery(i, 'arrow_right', 10, false), -13, 0, 57));
    }
    for (let i = 0; i < SECTION_SHORT; i++) {
      track.push(new TrackPiece(generate_scenery(i), -11, 0));
    }
    for (let i = 0; i < SECTION_SHORT; i++) {
      track.push(new TrackPiece(generate_scenery(i), -9, 0));
    }

    // straight
    for (let i = 0; i < SECTION_MEDIUM; i++) {
      track.push(new TrackPiece(generate_scenery(i), 0, 0));
    }

    // cosine hills
    for (let i = 0; i < SECTION_LONG; i++) {
      track.push(new TrackPiece(generate_scenery(i), 0, Math.cos(i / 20) * 5));
    }

    // Mild upward slope - the purpose is to reset the Y scrolling of the background so it roughly matches the
    // background position at the start of the lap
    for (let i = 0; i < SECTION_LONG; i++) {
      track.push(new TrackPiece(generate_scenery(i, 'billboard03'), 0, 0.25));
    }

    // short straight
    for (let i = 0; i < SECTION_SHORT; i++) {
      track.push(new TrackPiece(generate_scenery(i, 'billboard03'), 0, 0));
    }
  }

  return track;
}

class Game {
  constructor(controls = null) {
    this.track = make_track();

    // We only create a player car (in setup_cars) when there is a controls object
    this.player_car = null;
    this.camera_follow_car = null;

    this.setup_cars(controls);

    this.camera = new Vecta3D(0, 400, 0);

    this.background = 'background';
    this.bg_offset = new Vecta(Math.floor(-images[this.background].width / 2), 30);

    this.first_frame = true;
    this.on_screen_debug_strs = [];
    this.frame_counter = 0;
    this.timer = 0;
    this.race_complete = false;
    this.time_up = false;

    if (this.player_car != null) {
      this.start_timer = 3.999;
      play_music("engines_startline");
    }
    else {
      // Race starts immediately on title screen
      this.start_timer = 0;
    }
  }

  setup_cars(controls) {
    this.cars = [];  // Will be kept in sorted order of position
    for (let i = 0; i < NUM_CARS; i++) {
      let z = -3 - (i * GRID_CAR_SPACING),
          x = ((i % 2) === 0) ? -400 : 400;
      if ((i === 0) && (controls != null)) {
        // Don't create player car on title screen
        this.player_car = new PlayerCar(new Vecta3D(x, 0, z), controls);
        this.cars.push(this.player_car);
      }
      else {
        this.cars.push(new CPUCar(new Vecta3D(x, 0, z),
                                  remap(i, 0, NUM_CARS - 1, 1.5, 2),
                                  remap(i, 0, NUM_CARS - 1, CPU_CAR_MIN_TARGET_SPEED, CPU_CAR_MAX_TARGET_SPEED)));
      }
    }

    if (this.player_car != null) {
      this.camera_follow_car = this.player_car;
    }
    else {
      this.camera_follow_car = this.cars[0];
    }
  }

  update(delta_time) {
    this.timer += delta_time;
    this.frame_counter += 1;

    // Race start sequence
    if (this.start_timer > 0) {
      // Ensure cars are added to the appropriate track piece's car list, so that
      // they're displayed during the start countdown (during which time their update is not called)
      for (let car of this.cars) {
        car.update_current_track_piece();
      }
      let timer_old = this.start_timer;
      this.start_timer = Math.max(0, this.start_timer - delta_time);
      // Every second of the countdown, make a sound effect
      if (this.start_timer === 0) {
        // Go!
        // Ambience is stereo so is treated as music
        play_music("ambience");
        game.play_sound("gobeep");
      }

      else if (Math.trunc(timer_old) !== Math.trunc(this.start_timer)) {
        game.play_sound("startbeep");
      }
    }

    let old_camera_z = this.camera.z,
        prev_ahead = this.get_first_track_piece_ahead(old_camera_z)[0];

    // If race has started, update all cars
    if (this.start_timer === 0) {
      for (let car of this.cars) {
        car.update(delta_time);
      }
    }

    // Is the race complete?
    if ((!this.race_complete) && (this.player_car != null)) {
      // End the game if lap time reaches 4 mins
      // This serves two purposes:
      // 1) Prevent lap time text from overflowing its area (would happen after 10 mins)
      // 2) If the game is being demoed in public, and someone starts playing and then leaves before finishing
      //    a race, the game will eventually end so that the next player can start a fresh race without having
      //    to quit and re-run the game
      // Also allow player to end the game by pressing Escape
      if ((this.player_car.lap_time >= (60 * 4)) || keyboard[keys.ESCAPE]) {
        stop_music();
        this.time_up = true;
        this.race_complete = true;
      }

      else if (this.player_car.lap > NUM_LAPS) {
        stop_music();
        this.race_complete = true;

        this.play_sound("game_complete");
      }

      // Sort cars in the list based on race positions
      this.cars.sort((a, b) => (a.pos.z - b.pos.z));
    }

    // Update camera position to follow player car
    this.camera.x = this.camera_follow_car.pos.x;
    this.camera.z = this.camera_follow_car.pos.z + CAMERA_FOLLOW_DISTANCE;

    // As camera moves around corners, add to bg_offset and shift car X position so that steering is required on corners

    // Get the new camera pos and determine which track piece it's on. The logic is different depending on whether
    // the position change goes from one track piece to the next, or is within one track piece
    let new_camera_z = this.camera.z,
        new_ahead = this.get_first_track_piece_ahead(new_camera_z)[0],

    // We need to deal with not just interpolating during movement within one track piece, but also when we pass the
    // boundary of a track piece.
    // We need to know how far the camera has travelled since the start of the frame and work out which portion of the
    // movement covers which track piece.
    // It's also possible for the movement to be across more than two track pieces.

    // Example
    // track i   z   offset_x
    // 5         -5  0
    // 6         -6  1000
    // 7         -7  0

    // Car start Z = -5      First track piece ahead = 5 (offset 0)
    // Car end Z = -5.5      First track piece ahead = 6 (offset 1000)
    // Offset change = 500

    // Car start Z = -5.4    First track piece ahead = 6 (offset 1000)
    // Car end Z = -5.5      First track piece ahead = 6 (offset 1000)
    // Offset change = 100

    // Car start Z = -5      First track piece ahead = 5 (offset 0)
    //                       Spans whole of piece 6 (offset 1000)
    // Car end Z = -6.1      First track piece ahead = 7 (offset 0)
    // Offset change = 1000

    // Car start Z = -5.001  First track piece ahead = 6 (offset 1000)
    // Car end Z = -6.1      First track piece ahead = 7 (offset 0)
    // Offset change = 999.9

    // Get distance from here to next SPACING increment or new camera z, whichever is a smaller change (higher number)
    // Ignore if camera moved backwards (debug camera only), or the camera is before the start of the track
    // Don't do this on first frame, as camera won't have its correct initial Z position at the beginning of the frame
        distance = old_camera_z - new_camera_z,
        offset_change = new Vecta(0, 0);
    if ((distance > 0) && (!this.first_frame) && (prev_ahead >= 0) && (new_ahead >= 0)) {
      let old_z_next_spacing_boundary = Math.floor(old_camera_z / SPACING) * SPACING,
          new_z_prev_spacing_boundary = (Math.floor(new_camera_z / SPACING) * SPACING) + SPACING,
          prev_track = this.track[prev_ahead],
          new_track = this.track[new_ahead],
          distance_first = old_camera_z - old_z_next_spacing_boundary,
          distance_last = new_z_prev_spacing_boundary - new_camera_z,
          fraction_first = distance_first / SPACING,
          fraction_last = distance_last / SPACING,
          offset_change = (new Vecta(prev_track.offset_x, prev_track.offset_y)).multiply(fraction_first).add(
            (new Vecta(new_track.offset_x, new_track.offset_y)).multiply(fraction_last)),
          background_width = images[this.background].width,
          fraction;
      if (new_ahead > prev_ahead) {
        // Movement touches at least two track pieces
        // Figure out how much of the movement was within the old and new track pieces, plus whether there
        // are any intermediate track pieces between them (whose offsets will be fully applied)

        // What proportion of the old and new track pieces have we covered?

        // assert stops the program with an AssertionError if the specified condition is false. Both fractions
        // should always be between zero and one, and if they aren't then we want to know about it. This assertion
        // may trigger with very low values of SPACING, possibly due to floating point inaccuracy.
        console.assert((0 <= fraction_first) && (fraction_first <= 1) && (0 <= fraction_last) && (fraction_last <= 1));

        // If difference between prev_ahead and new_ahead is more than 1, that means the movement involves
        // three or more track pieces. We will have passed 100% of each of the in-between track pieces, so we
        // fully add their offsets
        if ((new_ahead - prev_ahead) > 1) {
          for (let i = prev_ahead + 1; i < new_ahead; i++) {
            offset_change = offset_change.add(new Vecta(this.track[i].offset_x, this.track[i].offset_y));
          }
        }
      }

      else {
        // Movement was just within one track piece
        fraction = distance / SPACING;
        console.assert((0 <= fraction) && (fraction <= 1));
        offset_change = (new Vecta(prev_track.offset_x, prev_track.offset_y)).multiply(fraction);
      }

      // Shift background by the calculated offset
      this.bg_offset = this.bg_offset.add(offset_change);

      // Keep bg_offset.x within the range -backgroundwidth to +backgroundwidth
      while (this.bg_offset.x < -background_width) {
        this.bg_offset.x += background_width;
      }
      while (this.bg_offset.x > background_width) {
        this.bg_offset.x -= background_width;
      }
    }

    // Shift player car's X offset - this means the car will go off the track if you go around a corner without
    // steering. Without this, the car would magically stick to the track as if the corner wasn't there - because
    // the curvature is really just a visual effect!
    if (this.player_car != null) {
      this.player_car.set_offset_x_change(offset_change.x);
    }

    // This deals with moving the background when the camera is moving backwards, which will only happen if the
    // player uses the down arrow key debug mode
    if (new_ahead < prev_ahead) {
      this.bg_offset.x -= this.track[prev_ahead].offset_x;
      this.bg_offset.y -= this.track[prev_ahead].offset_y;
    }

    this.first_frame = false;
  }

  draw() {
    // Fill background with single colour
    // We use a different background colour depending on the Y offset of the background image, because
    // the top and bottom of that image are different colours
    if (this.bg_offset.y > 0) {
      screen.fill([0, 20, 117]);
    }
    else {
      screen.fill([0, 77, 180]);
    }

    // Profiling times
    let times = new Map([
      ["scenery_scale", 0],
      ["car_scale", 0],
      ["prepare_draw_cars", 0]]),
        background_width = images[this.background].width,
        self = this,
        profiler;

    // Draw background
    // Need to draw either one or two backgrounds - second copy is for wrapping (when bg_offset.x changes enough that
    // we'd see the edge of the image)
    performance.mark('bg_start');
    this.on_screen_debug_strs.push(this.bg_offset.toString());
    screen.blit(this.background, [this.bg_offset.x, this.bg_offset.y]);
    if (this.bg_offset.x > 0) {
      screen.blit(this.background, [this.bg_offset.x - background_width, this.bg_offset.y]);
    }
    if ((this.bg_offset.x + background_width) < WIDTH) {
      screen.blit(this.background, [this.bg_offset.x + background_width, this.bg_offset.y]);
    }
    performance.mark('bg_end');
    profiler = performance.measure('bg_duration', 'bg_start', 'bg_end');
    times.set("bg", profiler.duration);

    function transform(point_v3, w = null, h = null, clipping_plane = CLIPPING_PLANE) {
      // This local function receives a point as a Vector3 and transforms it into a Vector2 point in screen space
      // When called for a car or scenery item, w and h are specified, referring to the size of the original
      // sprite, so it also calculates and returns the scaled width and height, based on the distance from the camera
      let newpoint = point_v3.subtract(self.camera),
          point_v2;
      if (newpoint.z > clipping_plane) {
        return (w == null) ? null : [null, null, null];
      }

      // Apply perspective and centre on the screen
      point_v2 = new Vecta((newpoint.x / newpoint.z) + HALF_WIDTH,
                           (newpoint.y / newpoint.z) + HALF_HEIGHT);

      if (w == null) {
        return point_v2;
      }
      else {
        return [point_v2, w / -newpoint.z, h / -newpoint.z];
      }
    }

    // offset and offset_delta keep track of the cumulative changes in track offsets (X and Y - Z remains as 0), so
    // that each track piece is drawn in the correct position
    let offset = new Vecta3D(0, 0, 0),
        offset_delta = new Vecta3D(0, 0, 0),

    // Tuples of pairs of Vector2s storing screen positions of left and right edges of the track, central
    // stripes and left/right rumble strips. We remember them so they don't need to be recalculated when joining up
    // a track piece or stripe with the previous one
        prev_track_screen = null,
        prev_stripe_screen = null,
        prev_rumble_left_outer_screen = null,
        prev_rumble_right_outer_screen = null,
        prev_yellow_line_left_outer_screen = null,
        prev_yellow_line_left_inner_screen = null,
        prev_yellow_line_right_outer_screen = null,
        prev_yellow_line_right_inner_screen = null,

    // Instead of drawing track pieces etc as we come across them, we store draw calls in this list. Then we once
    // we've finished going through track pieces, we execute the draw calls in reverse order, so that track
    // pieces, cars and scenery in the distance are drawn before things which are closer
        draw_list = [],
        is_first_track_piece_ahead = true,
        [first_track_piece_idx, current_piece_z] = this.get_first_track_piece_ahead(this.camera.z),

    // Index of the track piece that we're drawing, relative to first_track_piece_idx
        track_ahead_i = 0;

    function add_to_draw_list(drawcall, type = "?") {
      draw_list.push([drawcall, type]);
    }

    performance.mark('track_start');

    // Get index of first track piece that starts at or just in front of the camera Z position
    // This means the track piece we're currently part-way through won't be displayed, but that doesn't matter
    // as it would be off the bottom of the camera.

    // At the start of the loop body below, we subtract SPACING from current_piece_z. Therefore we must add SPACING
    // before the loop so that current_piece_z is correct for the first track piece.
    current_piece_z += SPACING;

    // Go through each track piece ahead
    for (let i = first_track_piece_idx; i < this.track.length; i++) {
      // Stop when we've displayed VIEW_DISTANCE number of track pieces
      track_ahead_i += 1;
      if (track_ahead_i > VIEW_DISTANCE) {
        break;
      }

      current_piece_z -= SPACING;
      let track_piece = this.track[i],

      // Because the camera is pointing down the negative Z axis, negative/positive X mean right/left from
      // camera's perspective
          left = new Vecta3D(track_piece.width / 2, 0, current_piece_z),
          right = new Vecta3D(-track_piece.width / 2, 0, current_piece_z),
          fraction;

      // Interpolate for X offset between first and next track piece. Without this, going around corners would
      // look very juddery
      if (is_first_track_piece_ahead) {
        // Get fraction between this and next
        // Current track piece is actually the first track piece IN FRONT of Z
        // And next is the one after that
        // So to find the fraction we need to add spacing
        fraction = inverse_lerp(current_piece_z - SPACING, current_piece_z, this.camera.z - SPACING);
        offset_delta = new Vecta3D(fraction * track_piece.offset_x, fraction * track_piece.offset_y, 0);
      }
      else {
        offset_delta = offset_delta.add(new Vecta3D(track_piece.offset_x, track_piece.offset_y, 0));
      }

      is_first_track_piece_ahead = false;

      offset = offset.add(offset_delta);

      left = left.add(offset);
      right = right.add(offset);

      // Calculate screen positions of track boundaries
      let left_screen = transform(left),
          right_screen = transform(right),

      // Calculate screen pos of central stripe
      // Always work out stripe points even for pieces which don't need them, because the next track piece may
      // make use of the calculated points to connect up to
          stripe_left = (new Vecta3D(HALF_STRIPE_W, 0, current_piece_z)).add(offset),
          stripe_right = (new Vecta3D(-HALF_STRIPE_W, 0, current_piece_z)).add(offset),
          stripe_left_screen = transform(stripe_left),
          stripe_right_screen = transform(stripe_right),

      // Calculate screen pos of outer parts of left/right rumble strips (can just use left/right track positions
      // for inner part that touches track)
          rumble_strip_left_outer = left.add(new Vecta3D(HALF_RUMBLE_STRIP_W, 0, 0)),
          rumble_strip_right_outer = right.subtract(new Vecta3D(HALF_RUMBLE_STRIP_W, 0, 0)),
          rumble_strip_left_outer_screen = transform(rumble_strip_left_outer),
          rumble_strip_right_outer_screen = transform(rumble_strip_right_outer),

      // Calculate screen pos of left and right yellow lines, which are just inside the outer edges of the track
          yellow_line_left_outer = left.subtract(new Vecta3D(YELLOW_LINE_DISTANCE_FROM_EDGE, 0, 0)),
          yellow_line_left_inner = yellow_line_left_outer.subtract(new Vecta3D(HALF_YELLOW_LINE_W, 0, 0)),
          yellow_line_right_outer = right.add(new Vecta3D(YELLOW_LINE_DISTANCE_FROM_EDGE, 0, 0)),
          yellow_line_right_inner = yellow_line_right_outer.add(new Vecta3D(HALF_YELLOW_LINE_W, 0, 0)),
          yellow_line_left_outer_screen = transform(yellow_line_left_outer),
          yellow_line_left_inner_screen = transform(yellow_line_left_inner),
          yellow_line_right_outer_screen = transform(yellow_line_right_outer),
          yellow_line_right_inner_screen = transform(yellow_line_right_inner),

          points;

      // Only draw if both points are in front of clipping plane
      if ((left_screen != null) && (right_screen != null)) {
        // To draw, there must be a previous track piece that we can connect to
        if (prev_track_screen != null) {
          function draw_points(points, col, id) {
            points = points.map((p) => (p instanceof Vecta) ? [p.x, p.y] : p);
            if (points.some((point) => (point[1] < HEIGHT))) {
              // point[1] gets Y for both tuple pair and Vector2
              if (OUTLINE_W === 0) {
                add_to_draw_list(() => screen.draw.filled_polygon(points, col), id);
              }
              else {
                add_to_draw_list(() => screen.draw.polygon(points, col), id);
              }
            }
          }

          // Draw stripe (3m on/off)
          if ((Math.floor(i / 3) % 2) === 0) {
            draw_points([stripe_left_screen, stripe_right_screen, prev_stripe_screen[1], prev_stripe_screen[0]], STRIPE_COLOUR, "stripe");
          }

          // Draw yellow lines
          // This is before the drawing of the track as we want to draw on top of the track, and items in the
          // draw list are drawn in reverse order
          if (SHOW_YELLOW_LINES) {
            draw_points([prev_yellow_line_left_outer_screen,
                         yellow_line_left_outer_screen,
                         yellow_line_left_inner_screen,
                         prev_yellow_line_left_inner_screen], YELLOW_LINE_COL, "yellow line L");

            draw_points([prev_yellow_line_right_outer_screen,
                         yellow_line_right_outer_screen,
                         yellow_line_right_inner_screen,
                         prev_yellow_line_right_inner_screen], YELLOW_LINE_COL, "yellow line R");
          }


          // Draw track
          points = [prev_track_screen[0], left_screen, right_screen, prev_track_screen[1]];
          draw_points(points, track_piece.col, "track");

          // Draw rumble strip
          // This is before trackside as it draws on top of trackside, and items in the draw list are drawn
          // in reverse order
          if (SHOW_RUMBLE_STRIPS) {
            // Alternating colours
            let rumble_col = ((Math.floor(i / 2) % 2) === 0) ? RUMBLE_COLOUR_1 : RUMBLE_COLOUR_2;
            draw_points([prev_rumble_left_outer_screen, prev_track_screen[0], left_screen, rumble_strip_left_outer_screen], rumble_col, "rumble L");
            draw_points([prev_rumble_right_outer_screen, prev_track_screen[1], right_screen, rumble_strip_right_outer_screen], rumble_col, "rumble R");
          }

          // Draw trackside
          if (SHOW_TRACKSIDE) {
            // Alternating colours
            let trackside_col = ((Math.floor(i / 5) % 2) === 0) ? TRACKSIDE_COLOUR_1 : TRACKSIDE_COLOUR_2;
            draw_points([points[2], points[3], [0, points[3].y], [0, points[2].y]], trackside_col, "trackside left");
            draw_points([points[0], points[1], [WIDTH - 1, points[1].y], [WIDTH - 1, points[0].y]], trackside_col, "trackside right");
          }
        }

        // Store screen positions of various parts of the track, as they form half of the polygon for the next
        // track piece
        prev_track_screen = [left_screen, right_screen];
        prev_stripe_screen = [stripe_left_screen, stripe_right_screen];
        prev_rumble_left_outer_screen = rumble_strip_left_outer_screen;
        prev_rumble_right_outer_screen = rumble_strip_right_outer_screen;
        prev_yellow_line_left_outer_screen = yellow_line_left_outer_screen;
        prev_yellow_line_left_inner_screen = yellow_line_left_inner_screen;
        prev_yellow_line_right_outer_screen = yellow_line_right_outer_screen;
        prev_yellow_line_right_inner_screen = yellow_line_right_inner_screen;

        // Show debug info for this track piece
        if (SHOW_TRACK_PIECE_INDEX || SHOW_TRACK_PIECE_OFFSETS) {
          let items = [];
          if (SHOW_TRACK_PIECE_INDEX) {
            items.push(i.toFixed());
          }
          if (SHOW_TRACK_PIECE_OFFSETS) {
            items.push(track_piece.offset_x.toFixed());
            items.push(track_piece.offset_y.toFixed());
          }
          add_to_draw_list(() => screen.draw.text(items.join(","), {
            pos: [left_screen[0], left_screen[1] - 30]
          }));
        }
      }

      // Draw scenery for the current track piece
      if (SHOW_SCENERY) {
        for (let obj of track_piece.scenery) {
          if ((track_ahead_i * SPACING) < obj.max_draw_distance) {
            let pos_v3 = (new Vecta3D(obj.x, 0, current_piece_z)).add(offset),
                billboard, pos, scaled_w, scaled_h;
            if ((this.camera.z - current_piece_z) > obj.min_draw_distance) {
              billboard = obj.get_image();
              [pos, scaled_w, scaled_h] = transform(pos_v3, images[billboard].width * obj.scale,
                                                    images[billboard].height * obj.scale);
              // If a piece of scenery is very close to the camera, the scaled size may become enormous.
              // Don't try to draw such scenery, due to memory and frame rate issues
              if ((pos != null) && (scaled_w < MAX_SCENERY_SCALED_WIDTH)) {
                // Anchor point at bottom
                pos = pos.subtract(new Vecta(Math.floor(scaled_w / 2), scaled_h));
                performance.mark(`scenery_scale_${ i }_start`);
                performance.mark(`scenery_scale_${ i }_end`);
                profiler = performance.measure(`scenery_scale_${ i }_duration`, `scenery_scale_${ i }_start`, `scenery_scale_${ i }_end`);
                times.set("scenery_scale", times.get("scenery_scale") + profiler.duration);
                add_to_draw_list(() => screen.blit(billboard, new Rect(pos.x, pos.y, Math.trunc(scaled_w), Math.trunc(scaled_h))),
                                 "scenery_draw");
              }
            }
          }
        }
      }

      // Draw cars
      performance.mark(`prepare_draw_cars_${ i }_start`);
      let cars_to_draw = [],
          car_offset, next_track_piece, pos_v3, scale;
      for (let car of track_piece.cars) {
        // Each car needs to be drawn during the track piece it is on, but with an additional offset interpolated
        // towards the next track piece, so that it starts turning a corner as it reaches the piece
        // Also, the order of  drawing needs to be correct if there is more than one car per track piece
        car_offset = new Vecta3D(offset);
        if ((car.pos.z % SPACING) !== 0) {
          // Interpolate offset between this and next track piece
          // Note that "Interpolate for X offset between first and next track piece"
          // will already have happened! Does that matter?

          // The following lines deal with the car when it's moving onto a track piece with an offset
          fraction = inverse_lerp(current_piece_z, current_piece_z - SPACING, car.pos.z);
          next_track_piece = this.track[i+1];
          car_offset = car_offset.add(new Vecta3D(fraction * next_track_piece.offset_x,
                                                  fraction * next_track_piece.offset_y, -fraction * SPACING));

          // This ensures that the car's forward motion is correct on pieces following a piece with an offset
          car_offset = car_offset.add(offset_delta.multiply(fraction));
        }

        // The rules for drawing the player car (or whichever car the camera is following, in demo mode) are
        // a bit different. If we drew it in the same way, its position on the screen would be a bit off as
        // it would start going around corners before the camera does. So don't apply any offset.
        // (For Y offset, you can achieve an interesting effect by changing 0 to -car_offset.y / 2, but
        // it is a bit glitchy sometimes so we've left it at zero)
        if (car == this.camera_follow_car) {
          car_offset.x = 0;
          car_offset.y = 0;
        }

        pos_v3 = (new Vecta3D(car.pos.x, 0, current_piece_z)).add(car_offset);
        scale = 2;

        // For CPU cars, choose the sprite to use based on the car's angle in relation to the camera
        if (car instanceof CPUCar) {
          // Approximate the angle we're seeing the car from, to determine the sprite
          // The further the car is ahead, the smaller the effect
          // The car sprite filenames end in a number in the range -4 to 4, where 0 is the car not turning,
          // -1 is the car turning slightly to the left, 1 is turning slightly to the right, etc
          let z_distance = Math.max(1, -(pos_v3.z - this.camera.z)),
              offset_for_angle = (pos_v3.x - this.camera.x) / z_distance,
              angle_sprite_idx;
          offset_for_angle += -car.steering * 10;
          angle_sprite_idx = Math.trunc(remap_clamp(offset_for_angle, -200, 200, -4, 4));

          // If this is the camera follow car (which for a CPU car will only be the case during
          // the title screen), limit to only the shallowest angles (-1 to 1), as this car is a stand-in
          // for the plyaer car and the player car only uses angles between -1 and 1
          if (car == this.camera_follow_car) {
            angle_sprite_idx = Math.min(Math.max(angle_sprite_idx, -1), 1);
          }

          car.update_sprite(angle_sprite_idx, false);
        }

        // Calculate screen pos and scaled sprite size for car
        let [pos, scaled_w, scaled_h] = transform(pos_v3,
                                                  images[car.image].width * scale,
                                                  images[car.image].height * scale,
                                                  CLIPPING_PLANE_CARS);

        if ((pos != null) && (scaled_w < MAX_CAR_SCALED_WIDTH)) {
          // Anchor point at bottom, centre
          pos = pos.subtract(new Vecta(Math.floor(scaled_w / 2), scaled_h));
          performance.mark(`car_scale_${ i }_start`);
          performance.mark(`car_scale_${ i }_end`);
          profiler = performance.measure(`car_scale_${ i }_duration`, `car_scale_${ i }_start`, `car_scale_${ i }_end`);
          times.set("car_scale", times.get("car_scale") + profiler.duration);

          // We can't send it to the draw list just yet as there might be more than one car on this track
          // piece and we need to draw them in order starting from the one furthest from the camera.
          // So we'll add it to a list to sort and draw later
          cars_to_draw.push({
            z: car.pos.z,
            drawcall: () => screen.blit(car.image, new Rect(pos.x, pos.y, Math.trunc(scaled_w), Math.trunc(scaled_h)))
          });

          if (SHOW_CPU_CAR_SPEEDS && (car instanceof CPUCar)) {
            add_to_draw_list(() => draw_text(`${ car.target_speed.toFixed() }`, pos.x, pos.y - 40));
          }
        }
      }

      performance.mark(`prepare_draw_cars_${ i }_end`);
      profiler = performance.measure(`prepare_draw_cars_${ i }_duration`, `prepare_draw_cars_${ i }_start`, `prepare_draw_cars_${ i }_end`);
      times.set("prepare_draw_cars", times.get("prepare_draw_cars") + profiler.duration);

      // Draw the cars that are on the current track piece,starting from the one with the lowest Z position
      cars_to_draw.sort((a, b) => (b.z - a.z));
      for (let entry of cars_to_draw) {
        add_to_draw_list(entry["drawcall"], "cars");
      }
    }

    // Draw everything in draw_list, in reverse order - so that items furthest ahead are drawn first
    for (let [draw_call, type] of draw_list.reverse()) {
      performance.mark(`draw_${ type }_start`);
      draw_call();
      performance.mark(`draw_${ type }_end`);
      profiler = performance.measure(`draw_${ type }_duration`, `draw_${ type }_start`, `draw_${ type }_end`);
      if (!times.has(type)) {
        times.set(type, profiler.duration);
      }
      else {
        times.set(type, times.get(type) + profiler.duration);
      }
    }

    // Is there an actual player car, or are we in demo mode?
    if (this.player_car != null) {
      // Show info text
      // Adapt to varying window widths by using fractions of WIDTH instead of absolute coordinates

      let player_pos = this.cars.indexOf(this.player_car) + 1;

      // Show race complete or time up screens if relevant
      if (this.time_up) {
        draw_text("TIME UP!", Math.floor(WIDTH / 2), HEIGHT * 0.4, true);
      }

      else if (this.race_complete) {
        draw_text("RACE COMPLETE!", Math.floor(WIDTH / 2), HEIGHT * 0.15, true);
        draw_text("POSITION", Math.floor(WIDTH / 2), HEIGHT * 0.3, true);
        draw_text(player_pos.toFixed(), Math.floor(WIDTH / 2), HEIGHT * 0.42, true);
        draw_text("FASTEST LAP", WIDTH * 0.25, HEIGHT * 0.55, true);
        draw_text(format_time(this.player_car.fastest_lap), WIDTH * 0.25, HEIGHT * 0.68, true);
        draw_text("RACE TIME", WIDTH * 0.75, HEIGHT * 0.55, true);
        draw_text(format_time(this.player_car.race_time), WIDTH * 0.75, HEIGHT * 0.68, true);
      }

      else {
        // Race not complete - show status text at top of screen

        // Show status background
        let status_x = (WIDTH / 2) - (565 / 2);
        screen.blit("status", [status_x, 0]);

        // Show lap
        draw_text(`${ this.player_car.lap.toFixed().padStart(2, '0') }`, status_x + 30, 37, false, "status1b_");

        // Show position
        draw_text(`${ player_pos.toFixed().padStart(2, '0') }`, status_x + 116, 37, false, "status1b_");

        // Show speed
        draw_text(`${ Math.trunc(this.player_car.speed).toFixed().padStart(3, '0') }`, status_x + 197, 37, false, "status1b_");

        // Show lap time
        draw_text(format_time(this.player_car.lap_time), status_x + 299, 37, false, "status2_");

        // Show fastest lap
        if (this.player_car.last_lap_was_fastest && (this.player_car.lap_time < 4)) {
          let y = HEIGHT * 0.4;
          draw_text("FASTEST LAP!", Math.floor(WIDTH / 2), y, true);
          draw_text(format_time(this.player_car.fastest_lap), Math.floor(WIDTH / 2), y + 60, true);
        }

        // Show final lap text
        // If we're currently showing fastest lap text, wait for that to disappear before showing the final
        // lap text
        let begin_time, end_time;
        if (this.player_car.last_lap_was_fastest) {
          begin_time = 4;
          end_time = 8;
        }
        else {
          begin_time = 0;
          end_time = 4;
        }
        if ((this.player_car.lap === NUM_LAPS) && (begin_time < this.player_car.lap_time) && (this.player_car.lap_time < end_time)) {
          draw_text("FINAL LAP!", Math.floor(WIDTH / 2), HEIGHT * 0.4, true);
        }
      }
    }

    // Show debug text
    if (SHOW_DEBUG_TEXT) {
      for (let i = 0; i < this.on_screen_debug_strs.length; i++) {
        screen.draw.text(this.on_screen_debug_strs[i], {
          pos: [0, 50 + (i * 20)]
        });
      }
    }
    this.on_screen_debug_strs.splice(0, this.on_screen_debug_strs.length);

    if (SHOW_PROFILE_TIMINGS) {
      performance.mark('track_end');
      profiler = performance.measure('track_duration', 'track_start', 'track_end');
      performance.clearMarks();
      performance.clearMeasures();
      console.log("track: " + profiler.duration + "ms " + Array.from(times.values()).reduce((a, b) => (a + b)));

      // if sum(times.values()) > 16:
      console.log(this.frame_counter, times);

      // test drawing a very large polygon
      // pygame.draw.polygon(screen.surface, (255,0,0), (Vector2(-4000,test), Vector2(WIDTH*4,test), Vector2(0,test+500)))
    }
  }

  /*
   * Returns index of track piece at the specified Z position, or None if the specified position is off the end
   * of the track
   * e.g. track piece 0 goes from Z 0 to -0.999, etc
   */
  get_track_piece_for_z(z) {
    let idx = -Math.trunc(z / SPACING);
    if (idx >= this.track.length) {
      return null;
    }
    else {
      return idx;
    }
  }

  /*
   * Returns index and Z position of first track piece ahead of or exactly at the specified Z position, or None,None
   * if the specified position is off the end of the track
   */
  get_first_track_piece_ahead(z) {
    let idx = -Math.trunc(Math.floor(z / SPACING)),
        first_piece_z = -idx * SPACING;
    if (idx >= this.track.length) {
      return [null, null];
    }
    else {
      return [idx, first_piece_z];
    }
  }

  play_sound(name, count = 1) {
    // Some sounds have multiple varieties. If count > 1, we'll randomly choose one from those
    // We don't play any sounds if there is no player (e.g. if we're on the menu)
    // Pygame Zero allows you to write things like 'sounds.explosion.play()'
    // This automatically loads and plays a file named 'explosion.wav' (or .ogg) from the sounds folder (if
    // such a file exists)
    // But what if you have files named 'explosion0.ogg' to 'explosion5.ogg' and want to randomly choose
    // one of them to play? You can generate a string such as 'explosion3', but to use such a string
    // to access an attribute of Pygame Zero's sounds object, we must use Python's built-in function getattr
    sounds[name+getRandomInteger(0, count)].play();
  }
}

let keyboard_controls, joystick_controls, state, game, accumulated_time, demo_reset_timer, demo_start_timer;

function get_joystick_if_exists() {
  return (Joystick.get_count() > 0) ? new Joystick(0) : null;
}

function setup_joystick_controls() {
  // We call this on startup, and keep calling it if no controller is present,
  // so a controller can be connected while the game is open
  Joystick.init();
  let joystick = get_joystick_if_exists();
  joystick_controls = (joystick != null) ? new JoystickControls(joystick) : null;
}

function update_controls() {
  keyboard_controls.update();
  // Allow a controller to be connected while the game is open
  if (joystick_controls == null) {
    setup_joystick_controls();
  }
  if (joystick_controls != null) {
    joystick_controls.update();
  }
}

const State = Object.freeze({
  TITLE: 1,
  PLAY: 2,
  GAME_OVER: 3
});


// Pygame Zero calls the update and draw functions each frame

function update(delta_time) {
  // delta_time is the time passed (in seconds) since the previous frame

  update_controls();

  function button_pressed_controls(button_num) {
    // Local function for detecting button 0 being pressed on either keyboard or controller, returns the controls
    // object which was used to press it, or None if button was not pressed
    for (let controls of [keyboard_controls, joystick_controls]) {
      // Check for fire button being pressed on each controls object
      // joystick_controls will be None if there no controller was connected on game startup,
      // so must check for that
      if ((controls != null) && controls.button_pressed(button_num)) {
        return controls;
      }
    }
    return null;
  }

  if (state === State.TITLE) {
    // Check for player starting game with either keyboard or controller
    let controls = button_pressed_controls(0);
    if (controls != null) {
      // Switch to play state, and create a new Game object, passing it a controls object
      state = State.PLAY;
      game = new Game(controls);
    }

    // If the demo race has been running for a while, reset it, otherwise the AI cars will run out of track!
    demo_reset_timer -= delta_time;
    demo_start_timer += delta_time;
    if (demo_reset_timer <= 0) {
      game = new Game();
      demo_reset_timer = 60 * 2;
      demo_start_timer = 0;
    }
  }

  else if (state === State.PLAY) {
    if (game.race_complete) {
      state = State.GAME_OVER;
    }
  }

  else if (state === State.GAME_OVER) {
    if (button_pressed_controls(0) != null) {
      // Go back into demo/title screen mode - create a new Game object without a player
      // First stop the player car's skid sound
      game.player_car.stop_engine_sound();

      state = State.TITLE;
      game = new Game();
      play_music("title_theme");
    }
  }

  // Call game.update each time while accumulated_time is above FIXED_TIMESTEP. If it is double or more of FIXED_TIMESTEP,
  // which would occur if the frame rate is low, we call game.update two or more times per frame
  accumulated_time += delta_time;
  while (accumulated_time >= FIXED_TIMESTEP) {
    accumulated_time -= FIXED_TIMESTEP;
    game.update(FIXED_TIMESTEP);
  }
}

function draw() {
  game.draw();

  if (state === State.TITLE) {
    if ((demo_reset_timer < 1) || (demo_start_timer < 1)) {
      // Fade out screen prior to resetting demo game, and fade in whenever demo (re)starts
      // Draw a black image with gradually increasing/decreasing opacity
      // An alpha value of 255 is fully opaque, 0 is fully transparent
      let value = (demo_reset_timer < 1) ? demo_reset_timer : demo_start_timer,
          alpha = Math.min(255, 255 - (value * 255));
      screen.draw.filled_rect(new Rect(0, 0, WIDTH, HEIGHT), [0, 0, 0, alpha]);
    }

    // Construct start game text
    // On macOS, encourage the user to use Z instead of left control to accelerate, because
    // Ctrl+arrow is the keyboard shortcut to switch desktop

    // Draw start game text
    draw_text(`PRESS ${ SPECIAL_FONT_SYMBOLS } OR LEFT CONTROL`, Math.floor(WIDTH / 2), HEIGHT - 82, true);

    // Draw logo - centred on X axis, centred on top third of the screen on Y axis
    let logo_img = images['logo'];
    screen.blit('logo', [Math.floor(WIDTH / 2) - Math.floor(logo_img.width / 2), Math.floor(HEIGHT / 3) - Math.floor(logo_img.height / 2)]);
  }
}

function play_music(name) {
  music.play(name);
}

function stop_music() {
  music.stop();
}

/*
##############################################################################
*/

function reset() {
  // Set up sound system and start music
  play_music("title_theme");

  // Set up controls
  keyboard_controls = new KeyboardControls();
  setup_joystick_controls();

  // Set up initial state and Game object
  state = State.TITLE;
  game = new Game();

  demo_reset_timer = 2 * 60;    // Demo race resets after 2 mins
  demo_start_timer = 0;

  accumulated_time = 0;
}

window.addEventListener('load', (event) => {
  screen.init();
});
</script>
</body>

</html>
